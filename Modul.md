**Modul dan Sub modul :**

**Persiapan Belajar:**

    Persetujuan Hak Cipta (Gratis)
    Pengenalan Kelas (Gratis)
    Prasyarat Kemampuan (Gratis)
    Prasyarat Tools (Gratis)
    Mekanisme Belajar (Gratis)
    Forum Diskusi
    Materi yang Akan Dibahas
    Glosarium
    Daftar Referensi

**Hapi Plugin dan Data Validation : 0/22**

    Pendahuluan Hapi Plugin dan Data Vali...
    Hapi Plugin
    Membuat Hapi Plugin
    Mendaftarkan Plugin pada Hapi Server
    Menerapkan Plugin pada Notes API - Me...
    Menyiapkan Struktur Proyek
    Membuat inMemory NotesService
    Membuat Notes Plugin - Membuat Router...
    Membuat Notes Plugin - Membuat Fungsi...
    Membuat Notes Plugin - Menggunakan Ro...
    Mendaftarkan Notes Plugin di Server Hapi
    Memahami Kata Kunci this
    Data Validation
    Data Validation Menggunakan Joi
    Menerapkan Data Validation pada Notes...
    Menerapkan Data Validation pada Notes...
    Menerapkan Data Validation pada Notes...
    Menerapkan Data Validation pada Notes...
    Menerapkan Custom Exceptions - Mengen...
    Menerapkan Custom Exceptions - Membua...
    Deploy Perubahan Hapi Plugin dan Data...
    Ikhtisar Hapi Plugin dan Data Validation

**Database dengan Amazon RDS : 0/22**

    Pendahuluan Database dengan Amazon RDS
    Pengenalan Database, Relational Datab...
    Jenis-Jenis Database
    Memasang PostgreSQL
    Membuat User dan Database di PostgreS...
    Pengenalan SQL (Structured Query Lang...)
    Menggunakan Database di Notes API
    Node-Postgres
    Membuat Database, Memasang Node-Postg...
    Membuat Tabel Notes dengan Teknik Mig...
    Membuat Postgres NotesService
    Membuat Postgres NotesService - Membu...
    Membuat Postgres NotesService - Membu...
    Membuat Postgres NotesService - Membu...
    Menggunakan Postgres NotesService di ...
    Mendeploy PostgreSQL ke Amazon RDS
    Pengenalan Amazon RDS
    Memberikan Hak Akses Amazon RDS ke IA...
    Membuat dan Meluncurkan Amazon RDS In...
    Mendeploy Perubahan Aplikasi ke EC2 I...
    Menghubungkan Amazon RDS Instance ke ...
    Ikhtisar Database dengan Amazon RDS

**Proyek Pertama : 0/3**

    Proyek Hapi Plugin, Data Validation, ...
    Kriteria Proyek OpenMusic API versi 1
    Proyek OpenMusic API versi 1 Kirim Su...

**Authentication dan Authorization : 0/49**

    Pendahuluan Authentication dan Author...
    Membuat Fitur Registrasi Pengguna di ...
    Membuat Skenario Testing dalam Mengel...
    Membuat Skenario Testing dalam Mengel...
    Membuat Skenario Testing dalam Mengel...
    Membuat Skenario Testing dalam Mengel...
    Membuat Skenario Testing dalam Mengel...
    Membuat Skenario Testing dalam Mengel...
    Membuat Skenario Testing dalam Mengel...
    Membuat UsersService
    Membuat UsersService - Membuat Fungsi...
    Membuat UsersService - Membuat Fungsi...
    Membuat Joi Schema dan Validator untu...
    Membuat Users Plugin - Membuat Berkas...
    Membuat Users Plugin - Menuliskan Kon...
    Membuat Users Plugin - Menuliskan Fun...
    Membuat Users Plugin - Menuliskan Use...
    Membuat Users Plugin - Menggunakan Us...
    Pengenalan Authentication
    Mengenal Skema Autentikasi pada Proto...
    Token-Based Authentication
    JWT
    Pola Token-Based Authentication mengg...
    Menerapkan Token-Based Authentication...
    Membuat Skenario Testing untuk Fitur ...
    Mengelompokkan dan Mengurutkan Penguj...
    Membuat Tabel Authentications
    Membuat AuthenticationsService
    Membuat AuthenticationsService - Memb...
    Membuat AuthenticationsService - Memb...
    Membuat AuthenticationsService - Memb...
    Menambahkan Fungsi verifyUsersCredent...
    Membuat Joi Schema dan Validator untu...
    Membuat JWT Token Manager
    Membuat JWT Token Manager - Membuat F...
    Membuat JWT Token Manager - Membuat F...
    Membuat JWT Token Manager - Membuat F...
    Membuat Authentications Plugin - Meny...
    Membuat Authentications Plugin - Meny...
    Membuat Authentications Plugin - Menu...
    Membuat Authentications Plugin - Meng...
    Memproteksi Resource Notes
    Pengenalan Authorization
    Menerapkan Authorization di Notes API...
    Menerapkan Authorization di Notes API...
    Menerapkan Authorization di Notes API...
    Menerapkan Authorization di Notes API...
    Menerapkan Authorization di Notes API...
    Ikhtisar Authentication dan Authoriza...

**Normalisasi Database : 0/21**

    Pendahuluan Normalisasi Database
    Pengenalan Normalisasi
    Tahapan Normalisasi
    Join Tabel
    Menerapkan Normalisasi Database di No...
    Menambahkan Foreign Key pada Kolom Owner
    Membangun Fitur Kolaborasi Catatan
    Membangun Fitur Kolaborasi Catatan - ...
    Membangun Fitur Kolaborasi Catatan - ...
    Membangun Fitur Kolaborasi Catatan - ...
    Membangun Fitur Kolaborasi Catatan - ...
    Membangun Fitur Kolaborasi Catatan - ...
    Membangun Fitur Kolaborasi Catatan - ...
    Membangun Fitur Kolaborasi Catatan - ...
    Membangun Fitur Kolaborasi Catatan - ...
    Mencoba Fitur Collaborations pada Not...
    Memperbaiki Kekurangan pada Notes API
    Memperbaiki Kekurangan pada Notes API...
    Memperbaiki Kekurangan pada Notes API...
    Deploy Perubahan Normalisasi Database
    Ikhtisar Normalisasi Database

**Proyek Kedua : 0/3**

    Proyek Authentication, Authorization,...
    Kriteria OpenMusic API versi 2
    Proyek OpenMusic API versi 2 Kirim Su...

**Message Broker dengan Amazon MQ : 0/18**

    Pendahuluan Message Broker dengan Ama...
    Apa itu Message Broker?
    Message Broker Model (Pola Distribusi...)
    Kasus Penggunaan Message Broker
    Memasang Message Broker Server Menggu...
    Dasar Penggunaan RabbitMQ di Node.js
    Mengimplementasikan Message Broker ke...
    Mengimplementasikan Message Broker ke...
    Mengimplementasikan Message Broker ke...
    Mengimplementasikan Message Broker ke...
    Mengimplementasikan Message Broker ke...
    Mengimplementasikan Message Broker ke...
    Deploy Penerapan Message Broker Mengg...
    Deploy Penerapan Message Broker Mengg...
    Deploy Penerapan Message Broker Mengg...
    Deploy Penerapan Message Broker Mengg...
    Deploy Penerapan Message Broker Mengg...
    Ikhtisar Message Broker dengan Amazon MQ

**Storage dengan Amazon S3 : 0/15**

    Pendahuluan Storage dengan Amazon S3
    Cara Mengirimkan Berkas Melalui Permi...
    Menerapkan Fitur Upload Gambar pada N...
    Menerapkan Fitur Upload Gambar pada N...
    Menerapkan Fitur Upload Gambar pada N...
    Menerapkan Fitur Upload Gambar pada N...
    Melayani Berkas Statis di Hapi
    Menggunakan Amazon S3 sebagai Storage...
    Menggunakan Amazon S3 sebagai Storage...
    Menggunakan Amazon S3 sebagai Storage...
    Menggunakan Amazon S3 sebagai Storage...
    Menggunakan Amazon S3 sebagai Storage...
    Menggunakan Amazon S3 sebagai Storage...
    Deploy Perubahan Storage dengan Amazo...
    Ikhtisar Storage dengan Amazon S3

**Caching Menggunakan Amazon ElastiCache : 0/16**

    Pendahuluan Caching menggunakan Amazo...
    Pengertian Cache
    Teknik Caching di RESTful API
    Mengenal Redis
    Memasang Redis secara Lokal
    Dasar Command-Line Redis
    Menerapkan Server-Side Caching pada R...
    Menerapkan Server-Side Caching pada R...
    Menerapkan Server-Side Caching pada R...
    Menerapkan Server-Side Caching pada R...
    Men-deploy Redis pada Amazon ElastiCache
    Men-deploy Redis pada Amazon ElastiCa...
    Men-deploy Redis pada Amazon ElastiCa...
    Men-deploy Redis pada Amazon ElastiCa...
    Men-deploy Redis pada Amazon ElastiCa...
    Ikhtisar Caching Menggunakan Amazon E...

**Penutup0/1**

    Rangkuman Kelas

**Proyek Akhir0/3**

    Proyek Message Broker, Storage, dan C...
    Kriteria OpenMusic API versi 3
    Proyek OpenMusic API versi 3 Kirim Su...

==============================================================================================================================

**Persiapan Belajar:**

    Persetujuan Hak Cipta (Gratis)
    Pengenalan Kelas (Gratis)
    Prasyarat Kemampuan (Gratis)
    Prasyarat Tools (Gratis)
    Mekanisme Belajar (Gratis)
    Forum Diskusi
    Materi yang Akan Dibahas
    Glosarium
    Daftar Referensi

================================

**Prasyarat Kemampuan**

Sebelum mengikuti kelas ini, idealnya Anda harus memiliki bekal kemampuan dalam membangun RESTful API sederhana menggunakan Node.js, khususnya framework Hapi. Berikut detail dari masing-masing kemampuan yang perlu Anda miliki.

Pengetahuan tentang Back-End

    Mengetahui istilah Back-End dan Front-End.
    Mengetahui apa itu server, cara client dan server berkomunikasi, dan mampu membuat permintaan HTTP menggunakan cURL ke server.
    Mengetahui apa itu web services dan web server, serta peran dan fungsi keduanya.
    Mengetahui arsitektur REST pada web services.
    Mengetahui desain yang baik dalam membuat RESTful API.

Node.js Basic

    Mampu menjalankan kode JavaScript melalui Node REPL maupun berkas JavaScript.
    Mengetahui fungsi dari member yang ada di global object Node.js, seperti global, process, dan console.
    Mampu melakukan modularisasi dengan menggunakan module.exports dan require (CommonJS).
    Mampu membuat event di Node.js menggunakan core module events.
    Mampu mengakses file system di Node.js menggunakan core module fs.
    Mampu melakukan teknik stream, baik ReadableStream ataupun WritableStream.
    Mampu membuat HTTP server sederhana yang dapat menangani dan menanggapi permintaan dari client menggunakan berbagai HTTP verb dan path.

Hapi Framework

    Mampu membuat HTTP server.
    Mampu me-routing HTTP server.
    Mampu menangani permintaan (request handling) yang datang ke server dan menanggapinya.
    Mampu mengubah response code maupun message ketika menanggapi permintaan.
    Mampu menggunakan format JSON dalam menanggapi permintaan.
    Mampu membuat RESTful API sederhana yang memiliki operasi Create, Read, Update, dan Delete.

Deployment menggunakan Amazon EC2

    Mampu membuat akun AWS.
    Mampu membuat IAM user untuk mengakses service Amazon EC2 secara penuh.
    Mampu meluncurkan Amazon EC2 dan mengonfigurasi kebutuhan deployment seperti memasang git, Node.js, hingga Process Manager.
    Mampu menjalankan atau men-deploy RESTful API di Amazon EC2.

Pengujian menggunakan Postman

    Mampu melakukan pengujian RESTful API secara manual.
    Mampu melakukan pengujian RESTful API secara otomatis dengan menuliskan kode testing.

Nah, bagaimana? Sudah cukupkah bekal Anda dalam mengikuti kelas ini? Jika belum, kami sangat menyarankan Anda untuk belajar semua materi di atas terlebih dahulu sebelum melanjutkan ke materi selanjutnya.

==========================================================================================================================

**Prasyarat Tools**

Selain kemampuan prasyarat yang sudah Anda ketahui di materi sebelumnya, kelas ini juga memiliki prasyarat tools yang perlu Anda penuhi terlebih dahulu.

Text Editor

Selama mengikuti kelas ini tentu Anda akan banyak sekali menuliskan kode. Kami merekomendasikan Anda untuk menggunakan VSCode. Text editor ini sangat populer dan gratis untuk digunakan. Selain itu, text editor ini memiliki plugin berlimpah yang dapat membuat fungsionalitas menjadi lebih kaya lagi. Visual Studio Code dapat dijalankan pada sistem operasi Windows, macOS, ataupun Linux. Untuk mengunduhnya, silakan kunjungi halaman unduh Visual Studio Code.

Node.js

Pastikan komputer Anda sudah terpasang Node.js dengan minimal versi 12 atau lebih tinggi. Untuk mengetahui versi Node.js yang terpasang, silakan tulis perintah ini pada Terminal atau CMD.

    node -v

Postman

Tools ini akan banyak digunakan pada kelas ini untuk menguji fungsionalitas dari RESTful API yang kita buat. Pastikan Anda sudah memasang Postman pada komputer Anda. Jika belum, silakan unduh Postman melalui tautan yang kami sediakan di bawah ini.

    Catatan:
    Agar dapat mengikuti materi dengan baik, kami sarankan Anda untuk mengunduh Postman versi 9 stabil. Link unduh di bawah ini kami sudah sesuaikan dengan versi tersebut.

    Windows
    Linux
    macOS

Proyek Notes API

**Selama pembelajaran di kelas ini, terdapat latihan yang perlu Anda ikuti. Latihan tersebut memiliki studi kasus yaitu membangun Notes API yang menerapkan data validation, database, authentication, authorization, dan fitur lainnya. Namun ketahuilah, untuk mengikuti latihan tersebut, kita tidak akan membuat proyek latihan dari awal, melainkan menggunakan proyek Notes API yang kami sediakan. Silakan unduh proyeknya melalui tautan ini.**

Postman Collection dan Environment untuk Notes API

Kebutuhan terakhir yakni Postman Collection dan Environment untuk menguji Notes API (yang kami sediakan) secara otomatis. Silakan unduh melalui tautan ini, kemudian import Postman Collection dan Environment-nya.

==========================================================================================================================

**Materi yang Akan Dibahas**

**Kelas ini terdiri dari 7 (tujuh) modul atau pembahasan pokok. Selama mengikuti kelas ini, Anda akan terus berlatih membuat proyek RESTful API, hingga pada akhir modul Anda berhasil membuat RESTful API yang menerapkan Database, Queue atau Message Broker, Storage, Caching, serta Authentication dan Authorization. Selain itu, Anda juga akan belajar beberapa prinsip yang baik dalam membuat RESTful API menggunakan Hapi Framework.** Penasaran?

Berikut rincian detail dari materi yang akan kita pelajari:

    Hapi Plugin dan Data Validation : Menggunakan sistem Plugin pada Hapi untuk mengelola source code agar lebih mudah dipelihara. Selain itu, Anda akan menerapkan teknik Data Validation menggunakan Joi untuk memastikan data yang dikirim oleh client sesuai dengan yang Anda harapkan.

    Database menggunakan Amazon RDS : Menggunakan database sebagai penyimpanan data yang persisten. Pada modul ini Anda akan menggunakan PostgreSQL sebagai database yang dipasang baik secara lokal (development) maupun production (menggunakan Amazon RDS).

    Authentication dan Authorization : Menerapkan teknik authentication untuk memvalidasi pengguna yang mengonsumsi RESTful API. Serta, menerapkan teknik authorization untuk memvalidasi resource yang merupakan hak pengguna. Authentication dan Authorization ini merupakan bentuk implementasi dari belajar Database menggunakan Amazon RDS.

    Normalisasi Database : Menggunakan teknik normalisasi database untuk membangun fitur kompleks yang membutuhkan join dari beberapa tabel.

    Message Broker dengan Amazon MQ : Menggunakan teknologi Message Broker untuk menangani permintaan secara asynchronous. Pada modul ini Anda akan menggunakan RabbitMQ sebagai Message Broker secara lokal maupun production (menggunakan Amazon MQ).

    Storage dengan Amazon S3 : Membuat Storage secara lokal menggunakan core modules fs dan memanfaatkan teknologi cloud dengan menggunakan Amazon S3.

    Caching menggunakan Amazon ElastiCache : Menggunakan teknologi memory caching untuk memberikan respons yang cepat dalam menampilkan resource. Pada modul ini Anda akan menggunakan Redis sebagai memory caching secara lokal maupun production (menggunakan Amazon ElastiCache).

Pada kelas ini juga terdapat tiga tugas atau submission yang harus Anda kirimkan. Materi kami desain secara terstruktur, jadi submission ke-1 dan ke-2 harus Anda selesaikan dulu agar bisa melanjutkan ke modul-modul yang ada pada kelas ini. Dan submission terakhir atau submission ke-3 merupakan proyek yang menentukan kelulusan Anda pada kelas ini.

Terdengar sedikit menyeramkan? Tidak kok! Tenang, seperti biasa kami selalu mencoba menyajikan materi dengan bahasa yang mudah untuk Anda pahami, juga latihan yang asyik untuk Anda ikuti.

Sudah tidak sabar untuk belajar? Yuk, lanjut ke materi selanjutnya.

==========================================================================================================================

**Glosarium**
1

1:1
1:1 atau one-to-one merupakan relasi database yang menunjukkan 1 baris/record/data dari suatu entitas hanya boleh berelasi dengan 1 data dari entitas lainnya.

1:n
**1:n atau one-to-many merupakan relasi database yang menunjukkan 1 data dari suatu entitas bisa berelasi dengan lebih dari 1 data dari entitas lainnya.**
A

Authentication
**Proses penentuan autentik (asli) atau tidaknya sebuah identitas.**

Authorization
**Proses pengecekan apakah pengguna autentik berhak mengakses resource yang diminta**

API
Singkatan dari "Application Programming Interface", yakni sekumpulan perintah, fungsi, protokol, dan objek yang dapat digunakan oleh programmer untuk membuat software atau berinteraksi dengan sistem eksternal.

AWS
Singkatan dari “Amazon Web Service”, yakni sekumpulan layanan-layanan berbasis Cloud Computing yang di sediakan oleh Amazon sejak tahun 2002.

B

Back-End
Merupakan bagian dari aplikasi yang bertanggung jawab untuk menyediakan kebutuhan yang tak terlihat oleh pengguna.

C

Cache
**Lapisan penyimpanan data berkecepatan tinggi yang menyimpan subset data, biasanya bersifat sementara, sehingga permintaan di masa mendatang untuk data tersebut dapat disajikan lebih cepat daripada mengakses lokasi penyimpanan utama data.**

Client
Dalam arsitektur client-server, client adalah perangkat yang memanfaatkan layanan dari server, biasanya berupa komputer desktop, laptop, smartphone, atau perangkat lain yang kompatibel dengan jaringan.

Consumer
Merupakan komponen yang mengonsumsi sebuah pesan dari queue.

CRUD
Singkatan dari Create, Read, Update, dan Delete yang merupakan operasi standar dalam mengelola data pada penyimpanan data atau database.

D

Database
Kumpulan data yang terstruktur dan tersimpan dalam suatu sistem komputer.

Deploy
**Singkatan dari istilah Deployment merupakan aktivitas yang membuat software dapat digunakan.**

DNS
**Singkatan dari Domain Name System, yakni server yang dapat menerjemahkan url dalam bentuk domain (contoh dicoding.com) menjadi alamat IP (Contoh: 99.83.220.86)
**

E

EC2
Merupakan salah satu layanan cloud computing yang disediakan oleh AWS. Melalui layanan ini, pengguna dapat menyewa komputer virtual untuk menjalankan sebuah layanan bisnis.

ElastiCache
**Merupakan service yang ditawarkan Amazon Web Service sebagai solusi dalam melakukan memory caching di infrastruktur cloud.**

Endpoint
Lokasi akhir yang menunjukkan di mana client dapat mengakses sumber daya dari API.

F

Filesystem
Sistem pengelolaan berkas atau file pada komputer.

Framework
Abstraksi dari sebuah teknologi yang sudah ada yang dibuat untuk memudahkan proses pengembangan dengan cara menyediakan fungsi-fungsi umum, tools, ataupun library. Dalam Bahasa Indonesia disebut juga sebagai kerangka atau kerangka kerja.

G

Git
Merupakan sebuah sistem yang membantu developer dalam melakukan versioning atau source code management terhadap aplikasi yang dikembangkan.

H

Hapi Plugin
Konsep pada Hapi Framework yang dapat membantu Anda secara mudah dalam break your application up atau memisah-misahkan komponen aplikasi yang Anda buat.

HTTP
Singkatan dari Hypertext Transfer Protocol, merupakan protokol internet yang berlokasi pada port 80. Protokol ini terkenal dengan pola request-response.

HTTPS
Singkatan dari Hypertext Transfer Protocol Secure, merupakan protokol internet kombinasi dari HTTP dengan protocol Secure Socket Layer (SSL)/Transport Layer Security (TLS).
J

Joi
**Tools yang digunakan untuk memudahkan proses validasi data dalam bentuk objek JavaScript melalui pola Schema Definition.**

JWT
**Salah satu format standar untuk proses tokenisasi. JWT menggunakan JSON sebagai format dalam menyimpan atau bertransaksi data**

M

m:n
**m:n atau many-to-many merupakan relasi database yang menunjukkan bahwa 1 data dari entitas A bisa berelasi dengan lebih dari 1 data dari entitas B, dan 1 data dari entitas B bisa berelasi dengan lebih dari 1 data dari entitas A.**

Message Broker
**Komponen yang membantu aplikasi, sistem, serta service untuk berkomunikasi satu sama lain dan bertukar informasi melalui sebuah pesan atau message.**

MQ
**MQ atau Message Queue adalah service yang ditawarkan oleh Amazon Web Service sebagai solusi Message Broker pada infrastruktur cloud.**

N

Node.js
Merupakan JavaScript Runtime yang dapat mengeksekusi kode JavaScript di luar browser.

P

Path
Dikenal juga sebagai Endpoint, merupakan lokasi yang menunjukkan di mana client dapat mengakses sumber daya dari API.

Postman
**Merupakan tools yang digunakan sebagai API caller. Postman memiliki fungsi yang relatif lengkap dalam melakukan HTTP Request.**

Producer
**Merupakan komponen yang memproduksi dan mengirimkan sebuah pesan ke queue.**

Q

Queue
**Merupakan tempat disimpannya pesan pada Message Broker selama pesan tersebut belum dikonsumsi oleh consumer.**

R

RDS
RDS atau Relational Database Service merupakan service yang ditawarkan Amazon Web Service sebagai solusi penyimpanan database relational di infrastruktur cloud.

REST
**Representational State Transfer adalah salah satu gaya arsitektur yang dapat diadaptasi ketika membangun web service.**

RESTful
**Web service yang menerapkan arsitektur REST.**

Repository
**Di dalam Git, respository merupakan wadah yang menampung berkas-berkas dalam berbagai versi pada sebuah proyek.**

Request
Pesan yang dikirim oleh client kepada server

Response
Pesan yang dikirim oleh server kepada client sebagai jawaban.

S

S3
**S3 atau Simple Storage Service merupakan service yang ditawarkan Amazon Web Service sebagai solusi storage pada infrastruktur cloud.**

S3 Bucket
**Merupakan istilah yang digunakan AWS sebagai wadah yang menampung berkas yang disimpan di S3.**

Server
**Dalam arsitektur client-server, server adalah perangkat yang dapat melayani permintaan dari perangkat lainnya.**

Storage
**Merupakan tempat penyimpanan sebuah data dalam bentuk berkas utuh pada komputer.**

SSH
**Secure Shell merupakan protokol jaringan kriptografi yang digunakan untuk mengoperasikan network services secara aman pada jaringan yang tidak terjamin keamanannya (salah satunya internet). SSH biasanya digunakan untuk melakukan remote command-line.**

W

Web Server
**Server yang dapat menjalankan program dan dapat diakses melalui internet atau intranet.**

Web Service
Program yang dijalankan di web server agar kebutuhan bisnis terpenuhi.

==========================================================================================================================

**Daftar Referensi**

[1] Hapi Community, “Plugins,” hapi.dev, 10-May-2021. [Daring]. Tersedia: https://hapi.dev/tutorials/plugins/?lang=en_US. [Diakses: 24-May-2021].

[2] Sideway, Joi Data Validation. [Daring]. Tersedia: https://joi.dev/. [Diakses: 24-May-2021].

[3] W. Martin, “Taming this In JavaScript With Bind Operator,” Smashing Magazine, 05-Oct-2018. [Daring]. Tersedia: https://www.smashingmagazine.com/2018/10/taming-this-javascript-bind-operator/. [Diakses: 24-May-2021].

[4] MDN, “Function.prototype.bind() - JavaScript: MDN,” JavaScript | MDN. [Daring]. Tersedia: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind. [Diakses: 24-May-2021].

[5] Sideway, “Joi 17.4.0 API Reference,” Joi Data Validation. [Daring]. Tersedia: https://joi.dev/api/. [Diakses: 24-May-2021].

[6] PostgreSQL, “Data Types,” PostgreSQL Documentation, 11-Feb-2021. [Daring]. Tersedia: https://www.postgresql.org/docs/current/datatype.html. [Diakses: 24-May-2021].

[7] B. Carlson, Node-Postgres Documentation. [Daring]. Tersedia: https://node-postgres.com/. [Diakses: 24-May-2021].

[8] “Postgresql Database Migration Management Tool for Node.js,” node-pg-migrate. [Daring]. Tersedia: https://salsita.github.io/node-pg-migrate. [Diakses: 24-May-2021].

[9] Auth-, “Token Based Authentication Made Easy,” Auth0. [Daring]. Tersedia: https://auth0.com/learn/token-based-authentication-made-easy/. [Diakses: 30-May-2021].

[10] “Authorization - HTTP: MDN,” HTTP | MDN. [Daring]. Tersedia: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization. [Diakses: 30-May-2021].

[11] G. Levin, “4 Most Used REST API Authentication Methods,” REST API and Beyond, 26-Jul-2019. [Daring]. Tersedia: https://blog.restcase.com/4-most-used-rest-api-authentication-methods/. [Diakses: 30-May-2021].

[12] “OAuth 2.0,” OAuth. [Daring]. Tersedia: https://oauth.net/2/. [Diakses: 30-May-2021].

[13] “Secure your site with HTTPS,” Google Search Central. [Daring]. Tersedia: https://developers.google.com/search/docs/advanced/security/https. [Diakses: 30-May-2021].

[14] “HTML,” HTML Standard, 26-May-2021. [Daring]. Tersedia: https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#attr-fs-enctype. [Diakses: 30-May-2021].

[15] “Authentication,” hapi.dev. [Daring]. Tersedia: https://hapi.dev/tutorials/auth/?lang=en_US. [Diakses: 31-May-2021].

==========================================================================================================================

**Hapi Plugin dan Data Validation : 0/22**

Pendahuluan Hapi Plugin dan Data Vali...
Hapi Plugin
Membuat Hapi Plugin
Mendaftarkan Plugin pada Hapi Server
Menerapkan Plugin pada Notes API - Me...
Menyiapkan Struktur Proyek
Membuat inMemory NotesService
Membuat Notes Plugin - Membuat Router...
Membuat Notes Plugin - Membuat Fungsi...
Membuat Notes Plugin - Menggunakan Ro...
Mendaftarkan Notes Plugin di Server Hapi
Memahami Kata Kunci this
Data Validation
Data Validation Menggunakan Joi
Menerapkan Data Validation pada Notes...
Menerapkan Data Validation pada Notes...
Menerapkan Data Validation pada Notes...
Menerapkan Data Validation pada Notes...
Menerapkan Custom Exceptions - Mengen...
Menerapkan Custom Exceptions - Membua...
Deploy Perubahan Hapi Plugin dan Data...
Ikhtisar Hapi Plugin dan Data Validation

===========================================

**Pendahuluan Hapi Plugin dan Data Validation**

Ceritanya, Anda sudah berhasil membangun RESTful API sederhana menggunakan framework Hapi. Dengan men-deploy-nya ke EC2, kini aplikasi yang Anda buat (Notes API yang kami sediakan) dapat diakses secara publik. Hal ini membuka kesempatan Notes Apps yang kita buat untuk diakses oleh banyak pengguna. Luar biasa!

Eits, jangan senang dulu ya, Anda perlu memastikan bahwa aplikasi yang Anda buat sudah siap untuk digunakan oleh banyak orang. Oke, untuk High Availability, AWS memang tangguh. Namun, bagaimana bila kita ingin terus mengembangkan fitur di Notes API kita? Mari kita lihat dari kesiapan struktur project-nya dulu.

Meskipun sudah menerapkan modularisasi, tetapi apakah Anda merasa kode yang ditulis dalam satu berkas JavaScript masih cukup banyak? Terutama pada berkas handler.js.

**Ah, mungkin saat ini Anda berpikir kode sebanyak itu masih dapat kita tangani dengan mudah. Namun, coba pikirkan kembali, bagaimana bila proyek back-end Notes API yang kita buat semakin berkembang? Contohnya, menerapkan fitur autentikasi, unggah gambar, ekspor data, dan sebagainya. Dapatkah satu berkas JavaScript menampung seluruh logika dari banyaknya fitur tersebut? Tentu tidak! Kita butuh cara yang lebih efektif sedari dini, apa pun caranya, bahkan struktur ulang kode sekalipun.**

**Selain itu, bila notes api semakin populer, bagaimana kita dapat memastikan data yang dikirim oleh client selalu sesuai dengan yang kita harapkan? Kita tak lagi berbicara mengenai satu client saja, melainkan bisa puluhan, ratusan, atau bahkan ribuan. Terbayang, betapa rumitnya memvalidasi data bila kita masih melakukannya secara manual.**

Nah, pada modul kali ini kita akan fokus bagaimana meraih pengetahuan dalam mengelola struktur proyek dan memvalidasi data yang diberikan oleh client dengan mudah. Tujuannya tak lain untuk meningkatkan kemudahan dalam mengembangkan aplikasi back-end kita ke depannya. Sehingga, di akhir modul ini Anda diharapkan dapat:

    Mengetahui Hapi Plugin.
    Memisahkan logika bisnis melalui Hapi Plugin.
    Mengetahui pentingnya validasi data.
    Menggunakan Joi sebagai data validator untuk memastikan data yang dikirim pengguna adalah valid.
    Mengimplementasikan custom error untuk merespons client error secara spesifik.
    Mendeploy perubahan yang terjadi pada lokal ke EC2 instance.

Yuk! Lanjut ke materi selanjutnya, ya.

==========================================================================================================================

Hapi Plugin = https://hapi.dev/plugins/

**Salah satu konsep besar yang perlu Anda ketahui ketika menggunakan Hapi framework adalah Plugin**. Sederhananya, **Plugin pada Hapi digunakan untuk memudahkan Anda dalam break your application up alias memisah-misahkan komponen aplikasi yang Anda buat**[1].

Komponen dapat berupa logika bisnis ataupun utilitas yang sering digunakan (reusable utilities). **Tujuan dari penggunaan Plugin itu sendiri tak lain untuk membuat logika bisnis atau utilitas terpisah atau terisolasi agar dalam mengembangkan aplikasi dapat terpetakan fokusnya.** Dengan begitu, Anda akan lebih mudah dalam mengelola proyek ke depannya.

**Sesuai namanya, komponen yang dipisahkan menggunakan Hapi Plugin akan benar-benar terisolasi, sehingga setiap komponen dapat dipasang (plug in) dan dicabut (plug out) dengan mudah.** Tanpa sadar, konsep plugin ini juga sering kita jumpai dalam kehidupan nyata.

Anggaplah sebuah komputer tidak memiliki fungsionalitas keyboard, mouse, atau Wi-Fi secara bawaan. Dengan begitu, kita bisa membayangkan plugin adalah sebuah dongle USB untuk keyboard wireless, mouse wireless, atau Wi-Fi adapter. Nah, agar komputer dapat menggunakan ketiga komponen tersebut, kita cukup plug in dongle USB-nya. Bila tidak ingin menggunakannya, cukup plug out dongle tersebut. Semudah itu!

**Plugin pada Hapi pun memiliki cara kerja yang sama. Ketika Anda membutuhkan fitur--katakanlah unggah gambar--hal yang perlu dilakukan hanyalah memasang Plugin unggah gambar pada Hapi server.** Kemudian, Hapi server secara instans akan memiliki fungsionalitas unggah gambar! Wah!

Eits, tunggu dulu! Untuk melakukan hal instans tersebut, tentu perlu proses. Prosesnya adalah bagaimana cara kita membuat atau mendapatkan plugin. Bila disambungkan ke kehidupan nyata, kita dapat dengan mudah membeli dongle USB di Amazon.com atau toko online lainnya. Nah, bagaimana dengan Hapi plugin?

# Anda dapat dengan mudah membuat Plugin secara mandiri, tentu kita akan mempelajari ini nanti. Atau untuk kebutuhan utilities, Anda juga bisa menggunakan beberapa plugin yang sudah dibuat oleh developer lain (third-party plugin). Karena plugin ini bersifat plug and play, tentu penggunaannya akan sangat mudah. Anda bisa melihat berbagai Plugin yang bisa digunakan pada halaman Plugins yang disediakan oleh Hapi. Untuk penggunaan third-party plugin itu sendiri akan kita gunakan nanti di modul authentication dan authorization, serta storage.

==========================================================================================================================

**Membuat Hapi Plugin**

**Selain menggunakan third-party plugin, kita bisa membuat Hapi plugin sendiri. Pembuatan Hapi plugin bisa dimanfaatkan untuk memudahkan pengelolaan aplikasi.** Karenanya, kita dapat memisahkan bisnis logika menjadi komponen yang terpisah dan terisolasi.

Tahukah Anda bahwa membuat Plugin pada Hapi sangatlah mudah? K**ita hanya perlu membuat sebuah objek yang memiliki properti register sebagai fungsi. Fungsi register ini akan dijalankan ketika plugin dipasang pada Hapi server.**

    const notesPlugin = {
      register: async (server, options) => {
        // contoh, menetapkan routing untuk /notes
        const notes = options.notes;
        server.route([
          {
            method: 'GET',
            path: '/notes',
            handler: () => {
              return notes;
            }
          }
        ])
      },
    }

**Fungsi register pada plugin dapat memiliki dua parameter, yakni server dan options.**

**Parameter server merupakan nilai dari server yang menggunakan plugin tersebut. Dengan begitu, kita dapat memanfaatkan nilai ini untuk melakukan konfigurasi ketika menginisialisasi server Hapi, sama halnya saat Anda melakukan hal tersebut tanpa plugin. Salah satu konfigurasi yang dapat kita lakukan adalah melakukan routing seperti kode yang Anda lihat di atas.**

    Sebenarnya, fungsi register dapat berjalan secara synchronous ataupun asynchronous. Namun, sebaiknya tetap async karena mungkin beberapa konfigurasi server yang Anda lakukan mengharuskan fungsi berjalan secara asynchronous, sehingga kita hanya perlu menggunakan keyword await. Hal ini dicontohkan juga pada dokumentasi Hapi.

**Parameter kedua adalah options. Parameter ini dapat menampung nilai-nilai yang dibutuhkan dalam menggunakan plugin. Pada contoh kode di atas, kita memanfaatkan options untuk menampung data notes yang akan digunakan dan dikembalikan pada handler route.** Sebagai plugin creator, Anda bebas memanfaatkan objek options ini sebagai penampung nilai apa pun yang dibutuhkan agar plugin dapat berjalan dengan baik. Nah, dari sisi plugin consumer, tentu ia harus menyediakan nilai-nilai tersebut sebelum menggunakannya.

Ketika membuat Hapi plugin, selain menyediakan fungsi register, sebaiknya Anda juga bisa menambahkan properti lain seperti name dan version sebagai informasi tambahan pada plugin-nya.

    const notesPlugin = {
      name: 'notes',
      version: '1.0.0',
      register: async (server, options) => {
        // contoh, menetapkan routing untuk /notes
        const notes = options.notes;
        server.route([
          {
            method: 'GET',
            path: '/notes',
            handler: () => {
              return notes;
            }
          }
        ])
      },
    }

==========================================================================================================================

**Mendaftarkan Plugin pada Hapi Server**

Sampai tahap ini, kita sudah mengetahui cara untuk membuat plugin. Anggaplah kita membuatnya pada berkas notesPlugin.js.

    notesPlugin.js

    module.exports = {
      name: 'notes',
      version: '1.0.0',
      register: async (server, options) => {
        const notes = options.notes;
        server.route([
          {
            method: 'GET',
            path: '/notes',
            handler: () => {
              return notes;
            }
          }
        ])
      },
    };

Lalu, bagaimana cara mendaftarkan plugin tersebut pada Hapi server? Mudah!

Pada Hapi server, kita dapat mendaftarkan banyak plugin sekaligus atau satu per satu melalui method await server.register(). Bila Anda hanya mendaftarkan satu plugin saja, cukup gunakan method tersebut dengan memberikan parameter objek yang memiliki properti plugin dan options.

     server.js

    const notesPlugin = require('./notesPlugin');
    const Hapi = require('@hapi/hapi')

    const init = async () => {
      const server = Hapi.server();

      // registrasi satu plugin
      await server.register({
        plugin: notesPlugin,
        options: { notes: [] },
      });

      await server.start();
    };

    init();

Berikan properti plugin dengan nilai plugin yang sudah dibuat. Kemudian berikan properti options dengan nilai options yang dibutuhkan untuk menjalankan plugin.

Bila proses registrasi plugin berhasil dalam contoh kasus Note App yang kita buat, maka route /notes akan mengembalikan nilai dari array yang diberikan pada options.

Anda juga bisa mendaftarkan banyak plugin sekaligus. Caranya, ubah parameter yang diberikan menjadi arrays yang di dalamnya menampung banyak objek dengan properti plugin dan options.

    server.js

    const notesPlugin = require('./notesPlugin');
    const otherPlugin = require('./otherPlugin');
    const Hapi = require('@hapi/hapi')

    const init = async () => {
      const server = Hapi.server();

      // registrasi banyak plugin sekaligus
      await server.register([
        {
          plugin: notesPlugin,
          options: { notes: [] },
        },
        {
          plugin: otherPlugin,
          options: { /* berikan nilai options jika dibutuhkan */ }
        }
      ]);

      await server.start();
    };

    init();

==========================================================================================================================

**Menerapkan Plugin pada Notes API**

Kita sudah mengetahui cara membuat dan mendaftarkan plugin pada Hapi server. Sekarang tunggu apa lagi, yuk kita restructure proyek Notes API dengan menerapkan plugin agar ke depannya proyek kita lebih mudah dikembangkan. Jadi, silakan buka kembali proyek notes-app-back-end pada VSCode, lalu pastikan proyeknya berjalan dengan lancar ya.

Mengenal Struktur Proyek yang Digunakan

Sebelum kita restructure, mari kita mengenal terlebih dahulu seperti apa struktur baru apa yang akan kita terapkan pada pada proyek notes-app-back-end.

    notes-app-back-end
    ├── src
    │ ├── api
    │ │ └── notes
    │ │   ├── handler.js
    │ │   ├── index.js
    │ │   └── routes.js
    │ ├── services
    │ │ └── inMemory
    │ │   └── NotesService.js
    │ └── server.js
    └── package.json

Struktur di atas adalah struktur yang akan kita adaptasi. Anda bisa lihat, pada cakupan paling atas terdapat folder src dan berkas package.json. Tidak ada yang berubah, keduanya masih memiliki fungsi yang sama seperti sebelumnya.

Beranjak ke dalam folder src. Di dalam folder src, terdapat folder api, services, dan satu berkas JavaScript server.js.

    src
    ├── api
    │ └── notes
    │  ├── handler.js
    │  ├── index.js
    │  └── routes.js
    ├── services
    │ └── inMemory
    │   └── NotesService.js
    └── server.js

Berkas server.js masih memiliki tanggung jawab yang sama, yakni memuat kode untuk membuat, mengonfigurasi, serta menjalankan HTTP server menggunakan Hapi. Bedanya, nanti proses registrasi plugin juga akan dilakukan di sini.

Sekarang, mari kita lihat isi dalam folder api.

    api
    └── notes
      ├── handler.js
      ├── index.js
      └── routes.js

Lanjut, folder api digunakan untuk menampung banyak folder yang merupakan Hapi plugin. Untuk kebutuhan saat ini, kita cukup membuat satu plugin saja, yakni notes.

    notes
    ├── handler.js
    ├── index.js
    └── routes.js

Di dalam setiap folder plugin (contohnya notes) akan terdiri dari tiga buah berkas JavaScript, yakni handler.js, index.js, dan routes.js.

Berkas index.js merupakan tempat di mana kita membuat plugin Hapi itu sendiri. Lalu bagaimana dengan routes.js dan handler.js? Tentu Anda sudah tahu fungsinya kan? Yap! Keduanya digunakan untuk mendefinisikan route /notes (routes.js) dan menampung function handler pada route /notes (handler.js). Kedua berkas tersebut (routes.js dan handler.js) tentu akan digunakan oleh berkas index.js.

Sudah jelas untuk folder /src/api? Mari kita pindah pembahasan ke folder /src/services.

    services
    └── inMemory
      └── NotesService.js

Sederhananya, folder services akan menampung segala fungsi yang digunakan untuk menulis, mendapatkan, mengubah, atau menghapus sebuah resource. Ingat, ini berbeda dengan handler. Service akan fokus dalam menangani operasi CRUD pada resource, sedangkan handler akan fokus dalam menangani response pada client.

Di kelas ini kita akan membuat banyak services, namun untuk kebutuhan saat ini cukup satu services dulu saja, yakni NotesService.js. Service ini digunakan untuk mengelola notes inMemory (di dalam memori menggunakan array).

Agar lebih mudah membayangkan seperti apa ketergantungan antar komponen yang ada, simak bagan berikut:

20210524075834278f2b3f210cbfde2650b38b0cc55290.png

==========================================================================================================================

Menyiapkan Struktur Proyek

Setelah mengetahui seperti apa struktur proyek yang akan kita adaptasi. Yuk, sekarang saatnya kita siapkan strukturnya pada proyek notes-app-back-end.

Silakan buka proyek notes-app-back-end. Jika Anda belum memilikinya, pastikan Anda sudah mengunduh proyeknya pada materi Prasyarat Tools.

202105111308183aad8aace7a1e4b60e02342eef629045.jpeg

Selanjutnya, kita coba jalankan dulu proyeknya. Buka Terminal melalui Terminal -> New Terminal.

20210511130920c7287672ded4d25968df97fbb940a345.jpeg

Kemudian tuliskan perintah berikut:

    npm run start-dev

    Pastikan seluruh package yang menjadi dependencies proyek ini sudah terpasang dan berada pada node_modules. Jika belum, jalankan terlebih dahulu npm install, kemudian baru jalankan proyek dengan npm run start-dev.

2021051113144210875cca35a536d2dcaaf06620482b88.jpeg

Sekarang proyek sudah berjalan. Untuk memastikan proyek berfungsi dengan normal, Anda bisa melakukan pengujian secara otomatis menggunakan postman.

Buka aplikasi Postman Anda. Kemudian, jalankan seluruh request yang berada pada Notes API Test collection.

20210511131752f0c8e58f8116c6a613bb29802d92db1e.jpeg

Pastikan seluruh pengujian berhasil dilakukan.

20210511131813a3616788d823096c8607e879d7f71d00.jpeg

Setelah memastikan semuanya aman, ayo kita kembali ke VSCode.

Sebelum membangun struktur proyek, mari kita lihat dulu struktur proyek yang ada saat ini.

202105111318328127d511f7d7bb9d54a75d62ca45c8e8.jpeg

Ini adalah proyek Back-End RESTful API yang mengusung fungsionalitas dari aplikasi catatan (Notes App). RESTful API ini memiliki fitur menyimpan, membaca, mengubah, dan menghapus catatan.

Di dalam folder src, kita bisa melihat berkas JavaScript handler.js, notes.js, routes.js, dan server.js. Sekarang, kita lihat seperti apa kode yang dituliskan di dalamnya. Kita mulai dari berkas server.js.

Silakan buka berkas server.js.

    server.js

    const Hapi = require('@hapi/hapi');
    const routes = require('./routes');


    const init = async () => {
      const server = Hapi.server({
        port: 5000,
        host: process.env.NODE_ENV !== 'production' ? 'localhost' : '0.0.0.0',
        routes: {
          cors: {
            origin: ['*'],
          },
        },
      });

      server.route(routes);

      await server.start();
      console.log(`Server berjalan pada ${server.info.uri}`);
    };

    init();

Berkas ini menampung kode untuk membuat, mengonfigurasi, dan menjalankan HTTP server menggunakan Hapi.

Berkas server.js ini memiliki ketergantungan terhadap berkas routes.js. Berkas routes.js itu sendiri menampung kode dalam menentukan routes pada Hapi server seperti path, method, dan handler yang digunakan.

router.js :

    const {
      addNoteHandler,
      getAllNotesHandler,
      getNoteByIdHandler,
      editNoteByIdHandler,
      deleteNoteByIdHandler,
    } = require('./handler');

    const routes = [
      {
        method: 'POST',
        path: '/notes',
        handler: addNoteHandler,
      },
      {
        method: 'GET',
        path: '/notes',
        handler: getAllNotesHandler,
      },
      {
        method: 'GET',
        path: '/notes/{id}',
        handler: getNoteByIdHandler,
      },
      {
        method: 'PUT',
        path: '/notes/{id}',
        handler: editNoteByIdHandler,
      },
      {
        method: 'DELETE',
        path: '/notes/{id}',
        handler: deleteNoteByIdHandler,
      },
    ];

    module.exports = routes;

Seperti yang Anda lihat, untuk fungsi handler pada berkas routes.js di ambil dari berkas handler.js. Tentu, seluruh logika dalam request handling ada di berkas ini (handler.js).

handler.js :

    const { nanoid } = require('nanoid');
    const notes = require('./notes');

    const addNoteHandler = (request, h) => {
      const { title = 'untitled', tags, body } = request.payload;

      const id = nanoid(16);
      const createdAt = new Date().toISOString();
      const updatedAt = createdAt;

      const newNote = {
        title, tags, body, id, createdAt, updatedAt,
      };

      notes.push(newNote);

      const isSuccess = notes.filter((note) => note.id === id).length > 0;

      if (isSuccess) {
        const response = h.response({
          status: 'success',
          message: 'Catatan berhasil ditambahkan',
          data: {
            noteId: id,
          },
        });
        response.code(201);
        return response;
      }

      const response = h.response({
        status: 'fail',
        message: 'Catatan gagal ditambahkan',
      });
      response.code(400);
      return response;
    };

    const getAllNotesHandler = () => ({
      status: 'success',
      data: {
        notes,
      },
    });

    const getNoteByIdHandler = (request, h) => {
      const { id } = request.params;

      const note = notes.filter((n) => n.id === id)[0];

      if (note !== undefined) {
        return {
          status: 'success',
          data: {
            note,
          },
        };
      }

      const response = h.response({
        status: 'fail',
        message: 'Catatan tidak ditemukan',
      });
      response.code(404);
      return response;
    };

    const editNoteByIdHandler = (request, h) => {
      const { id } = request.params;

      const { title, tags, body } = request.payload;
      const updatedAt = new Date().toISOString();

      const index = notes.findIndex((note) => note.id === id);

      if (index !== -1) {
        notes[index] = {
          ...notes[index],
          title,
          tags,
          body,
          updatedAt,
        };

        const response = h.response({
          status: 'success',
          message: 'Catatan berhasil diperbarui',
        });
        response.code(200);
        return response;
      }

      const response = h.response({
        status: 'fail',
        message: 'Gagal memperbarui catatan. Id tidak ditemukan',
      });
      response.code(404);
      return response;
    };

    const deleteNoteByIdHandler = (request, h) => {
      const { id } = request.params;

      const index = notes.findIndex((note) => note.id === id);


      if (index !== -1) {
        notes.splice(index, 1);
        const response = h.response({
          status: 'success',
          message: 'Catatan berhasil dihapus',
        });
        response.code(200);
        return response;
      }

      const response = h.response({
        status: 'fail',
        message: 'Catatan gagal dihapus. Id tidak ditemukan',
      });
      response.code(404);
      return response;
    };

    module.exports = {
      addNoteHandler,
      getAllNotesHandler,
      getNoteByIdHandler,
      editNoteByIdHandler,
      deleteNoteByIdHandler,
    };

notes.js :

    const notes = [];
    module.exports = notes;

==========================================================================================================================

Membuat inMemory NotesService

Kita akan mulai menuliskan kode untuk mengelola resource catatan pada NotesService.js.

Silakan buka berkas src -> services -> inMemory -> NotesService.js. Kemudian buat class NotesService yang memiliki properti this.\_notes sebagai array.

    class NotesService {
      constructor() {
        this._notes = [];
      }
    }

Lanjut, mari kita buat fungsi CRUD untuk mengelola data pada this.\_notes. Mari kita mulai dengan membuat method addNote yang menerima parameter objek note (title, body, tags).

    class NotesService {
      constructor() {
        this._notes = [];
      }

      addNote({ title, body, tags }) {

      }
    }

Di dalam fungsi addNote, kita tuliskan logika dalam memasukkan catatan pada array this.\_notes. Anda bisa mengambil referensi dari kode lama yang berada di dalam src -> handler.js. Yuk kita tuliskan.

    const { nanoid } = require('nanoid');

    class NotesService {
      constructor() {
        this._notes = [];
      }

      addNote({ title, body, tags }) {
        const id = nanoid(16);
        const createdAt = new Date().toISOString();
        const updatedAt = createdAt;

        const newNote = {
          title, tags, body, id, createdAt, updatedAt,
        };

        this._notes.push(newNote);
      }
    }

Lanjut, untuk memastikan newNote masuk ke dalam this.\_notes, kita bisa mengeceknya menggunakan fungsi filter untuk mencari berdasarkan id catatan yang baru saja dibuat (newNote), kemudian menyimpan hasilnya dalam variabel isSuccess.

    const { nanoid } = require('nanoid');

    class NotesService {
      constructor() {
        this._notes = [];
      }

      addNote({ title, body, tags }) {
        const id = nanoid(16);
        const createdAt = new Date().toISOString();
        const updatedAt = createdAt;

        const newNote = {
          title, tags, body, id, createdAt, updatedAt,
        };

        this._notes.push(newNote);

        const isSuccess = this._notes.filter((note) => note.id === id).length > 0;
      }
    }

Lakukan pengecekan pada variabel isSuccess. Jika bernilai false, maka buat fungsi addNotes membangkitkan Error. Sebaliknya (jika bernilai true), kembalikan fungsi dengan nilai id catatan baru.

    const { nanoid } = require('nanoid');

    class NotesService {
      constructor() {
        this._notes = [];
      }

      addNote({ title, body, tags }) {
        const id = nanoid(16);
        const createdAt = new Date().toISOString();
        const updatedAt = createdAt;

        const newNote = {
          title, tags, body, id, createdAt, updatedAt,
        };

        this._notes.push(newNote);

        const isSuccess = this._notes.filter((note) => note.id === id).length > 0;

        if (!isSuccess) {
          throw new Error('Catatan gagal ditambahkan');
        }

        return id;
      }
    }

Mantap! Selanjutnya, kita buat method getNotes untuk membaca seluruh note yang disimpan. Ini sangat mudah!

    const { nanoid } = require('nanoid');

    class NotesService {
      constructor() {
        this._notes = [];
      }

      addNote({ title, body, tags }) {
        /** kode disembunyikan */
      }

      getNotes() {
        return this._notes;
      }
    }

Sekarang buat method getNoteById dengan satu parameter id untuk membaca note yang disimpan berdasarkan id yang diberikan.

    const { nanoid } = require('nanoid');

    class NotesService {
      constructor() {
        this._notes = [];
      }

      addNote({ title, body, tags }) {
        /** kode disembunyikan */
      }

      getNotes() {
        /** kode disembunyikan */
      }

      getNoteById(id) {

      }
    }

Untuk mendapatkan note berdasarkan id, kita bisa manfaatkan fungsi filter.

    const note = this._notes.filter((n) => n.id === id)[0];

Lanjut, lakukan pengecekan pada variabel note. Bila note tidak ditemukan, maka bangkitkan Error. Selain itu, kembalikan fungsi dengan nilai note.

    const { nanoid } = require('nanoid');

    class NotesService {
      constructor() {
        this._notes = [];
      }

      addNote({ title, body, tags }) {
        /** kode disembunyikan */
      }

      getNotes() {
        /** kode disembunyikan */
      }

      getNoteById(id) {
        const note = this._notes.filter((n) => n.id === id)[0];
        if (!note) {
          throw new Error('Catatan tidak ditemukan');
        }
        return note;
      }
    }

Mantap! Lanjut kita buat fungsi editNoteById untuk mengubah data catatan yang disimpan. Fungsi ini menerima dua parameter yakni id dan data note terbaru dalam bentuk objek (payload yang akan diambil sebagian field yaitu title, body, tags).

    const { nanoid } = require('nanoid');

    class NotesService {
      constructor() {
        this._notes = [];
      }

      addNote({ title, body, tags }) {
        /** kode disembunyikan */
      }

      getNotes() {
        /** kode disembunyikan */
      }

      getNoteById(id) {
        /** kode disembunyikan */
      }

      editNoteById(id, { title, body, tags }) {

      }
    }

Di dalamnya, kita tuliskan logika dalam memperbarui data catatan pada array this.\_notes. Anda bisa mengambil referensi dari kode lama yang ada di handler.js.

    const { nanoid } = require('nanoid');

    class NotesService {
      constructor() {
        this._notes = [];
      }

      addNote({ title, body, tags }) {
        /** kode disembunyikan */
      }

      getNotes() {
        /** kode disembunyikan */
      }

      getNoteById(id) {
        /** kode disembunyikan */
      }

      editNoteById(id, { title, body, tags }) {
        const index = this._notes.findIndex((note) => note.id === id);

        if (index === -1) {
          throw new Error('Gagal memperbarui catatan. Id tidak ditemukan');
        }

        const updatedAt = new Date().toISOString();

        this._notes[index] = {
          ...this._notes[index],
          title,
          tags,
          body,
          updatedAt,
        };
      }
    }

Pastikan Anda membangkitkan Error ketika id note yang dikirim tidak ditemukan ya.

Kita lanjut buat fungsi deleteNoteById untuk menghapus note yang disimpan berdasarkan id.

    const { nanoid } = require('nanoid');

    class NotesService {
      constructor() {
        this._notes = [];
      }

      addNote({ title, body, tags }) {
        /** kode disembunyikan */
      }

      getNotes() {
        /** kode disembunyikan */
      }

      getNoteById(id) {
        /** kode disembunyikan */
      }

      editNoteById(id, { title, body, tags }) {
        /** kode disembunyikan */
      }

      deleteNoteById(id) {

      }
    }

Tuliskan kode untuk menghapus note dari array this.\_notes berdasarkan id yang diberikan. Anda juga bisa mengambil referensi dari kode lama untuk melakukannya.

    const { nanoid } = require('nanoid');

    class NotesService {
      constructor() {
        this._notes = [];
      }

      addNote({ title, body, tags }) {
        /** kode disembunyikan */
      }

      getNotes() {
        /** kode disembunyikan */
      }

      getNoteById(id) {
        /** kode disembunyikan */
      }

      editNoteById(id, { title, body, tags }) {
        /** kode disembunyikan */
      }

      deleteNoteById(id) {
        const index = this._notes.findIndex((note) => note.id === id);
        if (index === -1) {
          throw new Error('Catatan gagal dihapus. Id tidak ditemukan');
        }
        this._notes.splice(index, 1);
      }
    }

Jangan lupa untuk bangkitkan Error ketika note dengan id yang diberikan tidak ditemukan.

Terakhir, jangan lupa ekspor class NotesService agar dapat digunakan pada berkas JavaScript lain.

    const { nanoid } = require('nanoid');

    class NotesService {
      constructor() {
        this._notes = [];
      }

      addNote({ title, body, tags }) {
       /** kode disembunyikan */
      }

      getNotes() {
        /** kode disembunyikan */
      }

      getNoteById(id) {
        /** kode disembunyikan */
      }

      editNoteById(id, { title, body, tags }) {
        /** kode disembunyikan */
      }

      deleteNoteById(id) {
        /** kode disembunyikan */
      }
    }

    module.exports = NotesService;

NotesService.js selesai! Jangan lupa simpan perubahannya ya. Selanjutnya kita akan beranjak membuat notes plugin.

==========================================================================================================================

Membuat Notes Plugin

    Kita ingat kembali, "Hapi plugin notes ini akan bertanggung jawab untuk menangani setiap permintaan yang mengarah ke url /notes".

Membuat Router Notes

Kita mulai dengan menetapkan routes untuk notes plugin. Silakan buka src -> api -> notes -> routes.js. Kemudian buat fungsi routes yang mengembalikan array.

    const routes = () => [];

Tunggu-tunggu, mengapa fungsi? Mengapa tidak array langsung?

Nah, karena menggunakan plugin, kita akan menggunakan pendekatan yang berbeda. Kita tidak akan menggunakan fungsi-fungsi handler dari hasil impor secara langsung, melainkan handler yang akan digunakan pada route kali ini dimasukkan sebagai parameter fungsi. Inilah mengapa kita membuat fungsi yang mengembalikan array ketimbang membuat array secara langsung.

Silakan tambahkan parameter handler pada fungsi routes.

    const routes = (handler) => [];

Dengan menggunakan pendekatan seperti ini, berkas routes.js tidak perlu tahu dari mana handler berasal. Fungsi routes menjadi pure function karena tidak terikat pada sebuah objek secara langsung. Tentu ini bagus, bukan?

Oke, mari kita lanjutkan. Di dalam array dari fungsi routes, kita definisikan konfigurasi route. Karena kita hanya melakukan restrukturisasi, maka buat konfigurasinya sama seperti pada berkas src -> routes.js. Anda bisa tulis ulang nilainya dari sana.

    const routes = (handler) => [
      {
        method: 'POST',
        path: '/notes',
        handler: addNoteHandler,
      },
      {
        method: 'GET',
        path: '/notes',
        handler: getAllNotesHandler,
      },
      {
        method: 'GET',
        path: '/notes/{id}',
        handler: getNoteByIdHandler,
      },
      {
        method: 'PUT',
        path: '/notes/{id}',
        handler: editNoteByIdHandler,
      },
      {
        method: 'DELETE',
        path: '/notes/{id}',
        handler: deleteNoteByIdHandler,
      },
    ];

Untuk masing-masing properti handler, tentu perlu diubah nilainya karena kita tidak lagi menggunakan fungsi handler lama. Silakan ubah nilai properti pada masing-masing handler menjadi seperti ini (fokus terhadap kode yang diberi tanda tebal):

    const routes = (handler) => [
      {
        method: 'POST',
        path: '/notes',
        handler: handler.postNoteHandler,
      },
      {
        method: 'GET',
        path: '/notes',
        handler: handler.getNotesHandler,
      },
      {
        method: 'GET',
        path: '/notes/{id}',
        handler: handler.getNoteByIdHandler,
      },
      {
        method: 'PUT',
        path: '/notes/{id}',
        handler: handler.putNoteByIdHandler,
      },
      {
        method: 'DELETE',
        path: '/notes/{id}',
        handler: handler.deleteNoteByIdHandler,
      },
    ];

Dalam penetapan handler, ada dua hal yang berubah, yakni:

    Menggunakan fungsi yang merupakan member dari objek handler (parameter).
    Penamaan dari fungsi handler-nya.

Lihatlah bagaimana penamaan fungsi handler berubah. Contohnya dari addNoteHandler menjadi postNoteHandler, atau editNoteByIdHandler menjadi putNoteByIdHandler.

Mulai saat ini kita akan coba menetapkan standar pada penamaan dari fungsi handler. Pemberian nama fungsi handler diambil dari kombinasi method, kemudian path, dan diakhiri dengan kata ‘Handler’. Bila di path mengandung parameter, kita bisa kombinasikan juga parameter tersebut sesuai dengan penggunaannya.

Perhatikan juga bahwa penggunaan kata plural dan singular perlu disesuaikan. Bila handler hanya menerima atau mengembalikan satu data (single), maka gunakan kata singular daripada plural (note daripada notes). Jika handler menerima atau mengembalikan banyak data, maka gunakan plural daripada singular (notes daripada note).

    [
      {
        method: 'POST',
        path: '/notes',
        handler: handler.postNoteHandler, // postNoteHandler hanya menerima dan menyimpan "satu" note.
      },
      {
        method: 'GET',
        path: '/notes',
        handler: handler.getNotesHandler, // getNotesHandler mengembalikan "banyak" note.
      },
      {
        method: 'GET',
        path: '/notes/{id}',
        handler: handler.getNoteByIdHandler, // getNoteByIdHandler mengembalikan "satu" note.
      },
      {
        method: 'PUT',
        path: '/notes/{id}',
        handler: handler.putNoteByIdHandler, // putNoteByIdHandler hanya menerima dan mengubah "satu" note.
      },
      // dst
    ]

Loh, mengapa namanya perlu diubah? Alasannya tentu tak lain agar Anda lebih konsisten dalam memberikan nama fungsi handler. Mungkin saat ini belum begitu terasa karena masih segelintir fungsi yang dibuat. Namun, saat Anda telah membuat banyak fungsi dan proyek yang Anda buat sudah kompleks, tentu akan sulit untuk mencari fungsi bila tidak dinamai secara konsisten.

Oke, mari kita lanjut.

Jangan lupa untuk ekspor nilai routes agar nilainya dapat digunakan oleh berkas JavaScript lain, berikut adalah kode lengkapnya.

    const routes = (handler) => [
      {
        method: 'POST',
        path: '/notes',
        handler: handler.postNoteHandler,
      },
      {
        method: 'GET',
        path: '/notes',
        handler: handler.getNotesHandler,
      },
      {
        method: 'GET',
        path: '/notes/{id}',
        handler: handler.getNoteByIdHandler,
      },
      {
        method: 'PUT',
        path: '/notes/{id}',
        handler: handler.putNoteByIdHandler,
      },
      {
        method: 'DELETE',
        path: '/notes/{id}',
        handler: handler.deleteNoteByIdHandler,
      },
    ];

    module.exports = routes;

Berkas routes.js sudah selesai! Silakan simpan berkasnya dan kita lanjut ke berkas handler.js untuk membuat fungsi-fungsi handler-nya.

==========================================================================================================================

Membuat Fungsi Handler Notes

Buka berkas src -> api -> notes -> handler.js. Kemudian, buat class NotesHandler dan constructor-nya yang menerima satu parameter yakni service.

    class NotesHandler {
      constructor(service) {

      }
    }

Kemudian, buat properti _service dan inisialisasikan nilainya dengan service dari parameter constructor. Penggunaan nama variabel diawali underscore (_) dipertimbangkan sebagai lingkup privat secara konvensi.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }
    }

Parameter service nantinya akan diberikan nilai instance dari NotesService. Dengan begitu, NotesHandler memiliki akses untuk mengelola resource notes melalui properti this.\_service.

Oke, lanjut. Sekarang kita buat fungsi-fungsi handler yang sudah kita tetapkan pada berkas routes.js. Buat saja dulu fungsi-fungsinya secara kosong.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler() {
      }
      getNotesHandler() {
      }
      getNoteByIdHandler() {
      }
      putNoteByIdHandler() {
      }
      deleteNoteByIdHandler() {

      }
    }

Sebelum mulai menuliskan kode pada masing-masing fungsi handler, ada hal yang perlu Anda ketahui dulu tentang tanggung jawab fungsi handler saat ini.

Seperti yang sudah Anda ketahui, fungsi handler digunakan untuk menangani permintaan dari client yang datang kemudian memberikan respons dan sebaiknya memang hanya sebatas itu. Maksudnya, fungsi handler harus menghindari proses lain yang bukan bagian dari request handling. Contoh, fungsi handler tidak perlu tahu bagaimana cara resource disimpan, cara mendapatkan resource, dan cara-cara lainnya.

Ketahuilah! Fungsi handler lama (pada berkas src -> handler.js) masih mengetahui bagaimana cara atau proses penyimpanan catatan. Ya, tentu karena kita menuliskan semua kodenya di sana. Nah, saat ini kita tidak akan seperti itu lagi ya. Kita akan lebih mendisiplinkan diri untuk membuat fungsi sesuai tanggung jawabnya masing-masing.

Untunglah, karena kita sudah membuat NotesService, jadi proses pengelolaan seperti menyimpan, mendapatkan, mengubah, dan menghapus catatan tidak perlu lagi dilakukan pada request handler. Fungsi handler cukup memanggil fungsi publik dari NotesService melalui this.\_service.

Oke, mari kita mulai tuliskan kode handling mulai dari postNoteHandler.

Pertama, kita dapatkan dulu nilai title, tags, dan body dari request yang dikirim oleh client. Silakan tambahkan parameter request pada postNoteHandler, lalu dapatkan nilai title, tags, dan body dari objek request.payload. Jangan lupa tambahkan nilai default ‘untitled’ pada title.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request) {
        const { title = 'untitled', body, tags } = request.payload;
      }

      /** kode disembunyikan */
    }

Selanjutnya, untuk proses memasukan catatan baru, kita cukup panggil fungsi this.\_service.addNote kemudian berikan title, body, dan tags sebagai parameter objek note.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request) {
        const { title = 'untitled', body, tags } = request.payload;

        this._service.addNote({ title, body, tags });
      }

      /** kode disembunyikan */
    }

Karena fungsi this.\_service.addNote akan mengembalikan id catatan yang disimpan, maka buatlah variabel noteId untuk menampung nilainya. Ini karena nilai tersebut akan kita gunakan dalam merespons permintaan.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request) {
        const { title = 'untitled', body, tags } = request.payload;

        const noteId = this._service.addNote({ title, body, tags });
      }

      /** kode disembunyikan */
    }

Lanjut, kita kembalikan fungsi handler dengan respons yang memiliki kode 201.

Tambahkan parameter h di fungsi handler dan manfaatkanlah untuk membuat respons seperti pada kode lama (agar tidak mengganggu testing di Postman).

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        const { title = 'untitled', body, tags } = request.payload;

        const noteId = this._service.addNote({ title, body, tags });

        const response = h.response({
          status: 'success',
          message: 'Catatan berhasil ditambahkan',
          data: {
            noteId,
          },
        });
        response.code(201);
        return response;
      }

      /** kode disembunyikan */
    }

Ingat! Karena this.\_service.addNote bisa membangkitkan eror ketika catatan gagal dimasukan, maka kita perlu mengantisipasinya dengan menggunakan try .. catch. Mudahnya, Anda bisa membungkus seluruh logic di dalam block try, kemudian untuk block catch, kita kembalikan fungsi handler dengan respons gagal yang memiliki status code 400 dan pesan yang dibawa parameter error.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        try {
          const { title = 'untitled', body, tags } = request.payload;

          const noteId = this._service.addNote({ title, body, tags });

          const response = h.response({
            status: 'success',
            message: 'Catatan berhasil ditambahkan',
            data: {
              noteId,
            },
          });
          response.code(201);
          return response;
        } catch (error) {
          const response = h.response({
            status: 'fail',
            message: error.message,
          });
          response.code(400);
          return response;
        }
      }

      /** kode disembunyikan */
    }

Mantap! Kita lanjut yuk ke fungsi getNotesHandler.

Kode fungsi handler kedua ini akan sangat sederhana. Kita cukup dapatkan nilai notes dari this.\_service.getNotes(), kemudian kembalikan handler dengan respons yang sama seperti kode lama.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        /** kode disembunyikan */
      }

      getNotesHandler() {
        const notes = this._service.getNotes();
        return {
          status: 'success',
          data: {
            notes,
          },
        };
      }

      /** kode disembunyikan */
    }

Ah, sangat mudah sekali! Yuk lanjut ke fungsi getNoteByIdHandler.

Di dalam fungsi getNoteByIdHandler, pertama-tama kita perlu dapatkan nilai id note yang dikirim client melalui path parameter. Jadi, tambahkan parameter request pada fungsi handler ini kemudian dapatkan nilai id dari request.params.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
       /** kode disembunyikan */
      }

      getNotesHandler() {
        /** kode disembunyikan */
      }

      getNoteByIdHandler(request) {
        const { id } = request.params;
      }

      /** kode disembunyikan */
    }

Selanjutnya kita panggil fungsi this.\_service.getNoteById untuk mendapatkan objek note sesuai id yang diberikan client.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        /** kode disembunyikan */
      }

      getNotesHandler() {
        /** kode disembunyikan */
      }

      getNoteByIdHandler(request) {
        const { id } = request.params;
        const note = this._service.getNoteById(id);
      }

      /** kode disembunyikan */
    }

Lanjut, kita kembalikan respons success sesuai kode lama, tentunya dengan membawa objek note.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        /** kode disembunyikan */
      }

      getNotesHandler() {
        /** kode disembunyikan */
      }

      getNoteByIdHandler(request) {
        const { id } = request.payload;
        const note = this._service.getNoteById(id);
        return {
          status: 'success',
          data: {
            note,
          },
        };
      }

      /** kode disembunyikan */
    }

Mantap! Jangan lupa untuk menangani error yang dibangkitkan ketika catatan tidak ditemukan menggunakan try catch ya. Tambahkan parameter h dan manfaatkan untuk membuat kembalian response dengan response code 404 beserta pesan yang dibawa properti error pada block catch.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        /** kode disembunyikan */
      }

      getNotesHandler() {
        /** kode disembunyikan */
      }

      getNoteByIdHandler(request, h) {
        try {
          const { id } = request.params;
          const note = this._service.getNoteById(id);
          return {
            status: 'success',
            data: {
              note,
            },
          };
        } catch (error) {
          const response = h.response({
            status: 'fail',
            message: error.message,
          });
          response.code(404);
          return response;
        }
      }

      /** kode disembunyikan */
    }

Oke, lanjut ke method putNoteByIdHandler yuk.

Kita awali dengan mendapatkan nilai id dari request.params yang digunakan pada path parameter sebagai id dari note.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        /** kode disembunyikan */
      }

      getNotesHandler() {
        /** kode disembunyikan */
      }

      getNoteByIdHandler(request, h) {
        /** kode disembunyikan */
      }

      putNoteByIdHandler(request) {
        const { id } = request.params;
      }

      /** kode disembunyikan */
    }

Selanjutnya kita panggil fungsi this.\_service.editNoteById, kemudian masukkan id sebagai parameter pertama, dan request.payload yang akan menyediakan title, body, dan tags untuk objek note baru.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        /** kode disembunyikan */
      }

      getNotesHandler() {
        /** kode disembunyikan */
      }

      getNoteByIdHandler(request, h) {
        /** kode disembunyikan */
      }

      putNoteByIdHandler(request) {
        const { id } = request.params;

        this._service.editNoteById(id, request.payload);
      }

      /** kode disembunyikan */
    }

Lanjut, kita kembalikan response success dari handler ini seperti respons pada kode handler lama.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        /** kode disembunyikan */
      }

      getNotesHandler() {
        /** kode disembunyikan */
      }

      getNoteByIdHandler(request, h) {
       /** kode disembunyikan */
      }

      putNoteByIdHandler(request) {
        const { id } = request.params;

        this._service.editNoteById(id, request.payload);

        return {
          status: 'success',
          message: 'Catatan berhasil diperbarui',
        };
      }

      /** kode disembunyikan */
    }

Seperti biasa, jangan lupa untuk menangani error yang dibangkitkan ketika note id yang diperbarui tidak ditemukan.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        /** kode disembunyikan */
      }

      getNotesHandler() {
        /** kode disembunyikan */
      }

      getNoteByIdHandler(request, h) {
       /** kode disembunyikan */
      }

      putNoteByIdHandler(request, h) {
        try {
          const { id } = request.params;

          this._service.editNoteById(id, request.payload);

          return {
            status: 'success',
            message: 'Catatan berhasil diperbarui',
          };
        } catch (error) {
          const response = h.response({
            status: 'fail',
            message: error.message,
          });
          response.code(404);
          return response;
        }
      }

      /** kode disembunyikan */
    }

Oke, sudah mulai terbiasa kan? Yuk lanjut ke method terakhir, yakni deleteNoteByIdHandler.

Sama seperti fungsi-fungsi sebelumnya, pertama kita dapatkan dulu nilai note id yang dikirim client melalui path parameter. Jadi, silakan tambahkan parameter request pada handler ini dan manfaatkan request.params untuk mendapatkan nilai id.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        /** kode disembunyikan */
      }

      getNotesHandler() {
        /** kode disembunyikan */
      }

      getNoteByIdHandler(request, h) {
        /** kode disembunyikan */
      }

      putNoteByIdHandler(request, h) {
        /** kode disembunyikan */
      }

      deleteNoteByIdHandler(request) {
        const { id } = request.params;
      }
    }

Selanjutnya, panggil fungsi this.\_service.deleteNoteById, kemudian berikan nilai id sebagai parameter pemanggilan fungsinya.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        /** kode disembunyikan */
      }

      getNotesHandler() {
        /** kode disembunyikan */
      }

      getNoteByIdHandler(request, h) {
        /** kode disembunyikan */
      }

      putNoteByIdHandler(request, h) {
        /** kode disembunyikan */
      }

      deleteNoteByIdHandler(request) {
        const { id } = request.params;
        this._service.deleteNoteById(id);
      }
    }

Selepas itu, kembalikan dengan respons sukses yang sama seperti pada kode handler lama.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        /** kode disembunyikan */
      }

      getNotesHandler() {
        /** kode disembunyikan */
      }

      getNoteByIdHandler(request, h) {
        /** kode disembunyikan */
      }

      putNoteByIdHandler(request, h) {
        /** kode disembunyikan */
      }

      deleteNoteByIdHandler(request) {
        const { id } = request.params;
        this._service.deleteNoteById(id);
        return {
          status: 'success',
          message: 'Catatan berhasil dihapus',
        }
      }
    }

Jangan lupa juga tambahkan penanganan error menggunakan try catch bila id note yang hendak dihapus tidak ditemukan.

    class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        /** kode disembunyikan */
      }

      getNotesHandler() {
        /** kode disembunyikan */
      }

      getNoteByIdHandler(request, h) {
        /** kode disembunyikan */
      }

      putNoteByIdHandler(request, h) {
        /** kode disembunyikan */
      }

      deleteNoteByIdHandler(request, h) {
        try {
          const { id } = request.params;
          this._service.deleteNoteById(id);
          return {
            status: 'success',
            message: 'Catatan berhasil dihapus',
          };
        } catch (error) {
          const response = h.response({
            status: 'fail',
            message: error.message,
          });
          response.code(404);
          return response;
        }
      }
    }

Seluruh fungsi handler sudah selesai dituliskan!

Terakhir, jangan lupa untuk ekspor class NotesHandler agar dapat digunakan pada berkas JavaScript lain.

     class NotesHandler {
      constructor(service) {
        this._service = service;
      }

      postNoteHandler(request, h) {
        /** kode disembunyikan */
      }

      getNotesHandler() {
        /** kode disembunyikan */
      }

      getNoteByIdHandler(request, h) {
        /** kode disembunyikan */
      }

      putNoteByIdHandler(request, h) {
        /** kode disembunyikan */
      }

      deleteNoteByIdHandler(request, h) {
        /** kode disembunyikan */
    }

    module.exports = NotesHandler;

Oke. Sepertinya urusan dengan berkas handler.js sudah selesai. Simpan seluruh perubahan pada berkas handler.js dan kita lanjut untuk membuat notes plugin pada berkas index.js.

==========================================================================================================================

Menggunakan Router dan Handler pada Plugin Notes

Silakan buka berkas src -> api -> notes -> index.js, kemudian buatlah sebuah objek plugin pada module.exports.

    module.exports = {

    };

Beri properti name dengan notes, properti version dengan nilai ‘1.0.0’, dan fungsi register dengan fungsi yang memiliki dua parameter. Dua parameter fungsi ini adalah server dan objek options yang menampung service.

    module.exports = {
      name: 'notes',
      version: '1.0.0',
      register: async (server, { service }) => {

      },
    };

Lanjut, di dalam fungsi register, buatlah instance dari class NotesHandler dengan nama notesHandler. Kemudian nilai service sebagai pada constructor-nya. Jangan lupa untuk impor berkas handler.js agar NotesHandler dapat digunakan.

    const NotesHandler = require('./handler');

    module.exports = {
      name: 'notes',
      version: '1.0.0',
      register: async (server, { service }) => {
        const notesHandler = new NotesHandler(service);
      },
    };

Selanjutnya, daftarkan routes yang sudah kita buat pada server Hapi. Nah, caranya di dalam method server.route, panggil fungsi routes dan berikan notesHandler sebagai nilai handler-nya.

    const NotesHandler = require('./handler');

    module.exports = {
      name: 'notes',
      version: '1.0.0',
      register: async (server, { service }) => {
        const notesHandler = new NotesHandler(service);
        server.route(routes(notesHandler));
      },
    };

Terakhir, jangan lupa impor juga routes dari berkas routes.js.

    const NotesHandler = require('./handler');
    const routes = require('./routes');

    module.exports = {
      name: 'notes',
      version: '1.0.0',
      register: async (server, { service }) => {
        const notesHandler = new NotesHandler(service);
        server.route(routes(notesHandler));
      },
    };

Mantap! Akhirnya pembuatan plugin selesai juga. Simpan perubahan di berkas index.js. Pada materi selanjutnya, kita akan mencoba menggunakan atau mendaftarkan notes plugin yang sudah kita buat di server Hapi.

==========================================================================================================================

Mendaftarkan Notes Plugin di Server Hapi

Setelah selesai memindahkan proses routing dan request handling ke bentuk plugin serta membuat services dalam mengelola sebuah resource, sekarang kita coba gunakan plugin dan services tersebut ke Server Hapi.

Silakan buka berkas src -> server.js, kemudian import nilai notes plugin dan NotesService.

    const Hapi = require('@hapi/hapi');
    const routes = require('./routes');
    const notes = require('./api/notes');
    const NotesService = require('./services/inMemory/NotesService');

    /** kode disembunyikan */

Lalu di dalam fungsi init, buat instance dari NotesService dengan nama notesService.

    /** kode disembunyikan */

    const init = async () => {
      const notesService = new NotesService();

      /** kode disembunyikan */
    };

    init();

Selanjutnya, daftarkan plugin notes dengan options.service bernilai notesService menggunakan perintah await server.register tepat sebelum kode await server.start().

    /** kode disembunyikan */

    const init = async () => {
      const notesService = new NotesService();

      const server = Hapi.server({
        port: 5000,
        host: process.env.NODE_ENV !== 'production' ? 'localhost' : '0.0.0.0',
        routes: {
          cors: {
            origin: ['*'],
          },
        },
      });

      server.route(routes);

      await server.register({
        plugin: notes,
        options: {
          service: notesService,
        },
      });

      await server.start();
      console.log(`Server berjalan pada ${server.info.uri}`);
    };

    init();

Setelah plugin notes di daftarkan, kita bisa menghapus penggunaan routes lama. Silakan hapus kode:

    server.route(routes)

Jangan lupa hapus juga kode impornya karena sudah tidak digunakan lagi.

    const routes = require('./routes');

Sekarang, server.js tampak seperti ini:

    const Hapi = require('@hapi/hapi');
    const notes = require('./api/notes');
    const NotesService = require('./services/inMemory/NotesService');

    const init = async () => {
      const notesService = new NotesService();
      const server = Hapi.server({
        port: 5000,
        host: process.env.NODE_ENV !== 'production' ? 'localhost' : '0.0.0.0',
        routes: {
          cors: {
            origin: ['*'],
          },
        },
      });

      await server.register({
        plugin: notes,
        options: {
          service: notesService,
        },
      });

      await server.start();
      console.log(`Server berjalan pada ${server.info.uri}`);
    };

    init();

Simpan perubahan pada server.js dan pastikan tidak ada eror ketika server dijalankan. Bila ada eror, pasti ada kesalahan penulisan dalam menuliskan kode ketika membuat plugin atau services. Jika menghadapi eror, jangan panik ya! Silakan tanyakan ke forum diskusi dengan melampirkan pesan eror pada console dan kode yang Anda tuliskan.

Pastikan server Hapi sedang beroperasi, lalu silakan uji melalui Postman. Apakah restrukturisasi proyek yang kita lakukan berhasil?

20210512101328d1952c7a79fc63327ef646d05e5ef530.jpeg

Oh tidak! Ternyata banyak sekali yang gagal. Coba kita lihat pesan erornya pada Terminal VSCode yang mengoperasikan server.

    [nodemon] starting `node ./src/server.js`
    Server berjalan pada http://localhost:5000
    Debug: internal, implementation, error
    TypeError: Cannot read property '_service' of undefined
        at getNotesHandler (C:\javascript-projects\notes-app-back-end\src\api\notes\handler.js:32:24)
    at exports.Manager.execute (C:\javascript-projects\notes-app-back-end\node_modules\@hapi\hapi\lib\toolkit.js:57:29)
    at Object.internals.handler (C:\javascript-projects\notes-app-back-end\node_modules\@hapi\hapi\lib\handler.js:46:48)
    at exports.execute (C:\javascript-projects\notes-app-back-end\node_modules\@hapi\hapi\lib\handler.js:31:36)
    at Request._lifecycle (C:\javascript-projects\notes-app-back-end\node_modules\@hapi\hapi\lib\request.js:370:68)
    at processTicksAndRejections (internal/process/task_queues.js:93:5)
    at async Request._execute (C:\javascript-projects\notes-app-back-end\node_modules\@hapi\hapi\lib\request.js:279:9)

Lihat kode yang ditebalkan. Ternyata eror berasal dari properti this.\_service yang ada di berkas src -> api -> notes -> handler.js.

20210512101328f1845c234d651e106228ded98eb4a3a3.jpeg

Kira-kira kenapa ya? Kita akan coba perbaiki ini di materi selanjutnya.

==========================================================================================================================

Memahami Kata Kunci this

Kita menghadapi sebuah bugs yang memang sering terjadi ketika mengembangkan aplikasi menggunakan JavaScript. Bugs ini disebabkan oleh keyword this yang telah berubah dari instance class aslinya.

Jadi, ketika fungsi handler pada berkas src -> api -> notes -> handler.js dijalankan, nilai this berubah dari instance NotesHandler, menjadi objek route yang memanggilnya. Mengapa bisa demikian? Memang seperti itulah behavior JavaScript.

Untuk menjelaskan konteks dari nilai this di JavaScript sebenarnya sangat rumit, bahkan bisa menghabiskan waktu yang panjang. Maka dari itu, mari kita buat menjadi sederhana. Kita akan coba ambil contoh kasus yang serupa melalui kode yang lebih simpel sesuai kasus yang kita alami.

    Bila Anda ingin memahami perilaku this secara lebih detail, berikut ini adalah artikel yang cukup baik dalam menjelaskan perilaku this di JavaScript: Taming this In JavaScript With Bind Operator

Lihat kode di bawah ini.

class Game {
constructor(name) {
this.\_name = name;
}

loadingStuff() {
console.log('Memuat komponen permainan ...');
console.log(`Permainan ${this._name} akan segera dimulai!`);
console.log(this.\_name);
}
}

const gamePlayer = (game) => ({
play: game.loadingStuff,
})

const runner = () => {
const game = new Game('Catur');
gamePlayer(game).play();
}

runner();

**Tanpa menggunakan bind(),** perilaku this dalam metode loadingStuff() akan tergantung pada cara metode tersebut dipanggil. Dalam kasus ini, ketika kita memanggil gamePlayer(game).play(), metode play() akan menjadi referensi fungsi ke metode loadingStuff() dari objek game.

Namun, karena play() tidak secara langsung terikat ke instance Game, nilai this dalam metode loadingStuff() akan berubah dan tidak lagi merujuk pada instance Game. Sebagai gantinya, this akan merujuk pada objek yang memanggil metode play(), yaitu objek gamePlayer(game). Oleh karena itu, jika kita menjalankan kode di atas, akan terjadi kesalahan (TypeError) ketika mencoba mengakses this.\_name dalam metode loadingStuff(), karena this tidak memiliki properti \_name.

Dengan demikian, penting untuk menggunakan bind() dalam kasus ini untuk memastikan bahwa this dalam metode yang diikat tetap merujuk pada instance yang diinginkan.

    main.js

class Game {
constructor(name) {
this.\_name = name;
this.loadingStuff = this.loadingStuff.bind(this);
}

    loadingStuff() {
      console.log('Memuat komponen permainan ...');
      console.log(`Permainan ${this._name} akan segera dimulai!`);
      console.log(this._name);
    }

}

const gamePlayer = (game) => ({
play: game.loadingStuff,
})

const runner = () => {
const game = new Game('Catur');
gamePlayer(game).play();
}

runner();

​konsep this yg aneh di js dijelaskan oleh chat gpt :

Dalam kode yang diberikan, kita melihat penggunaan bind() dalam konstruktor kelas Game. Metode bind() digunakan untuk mengikat nilai this ke konteks yang ditentukan, dalam hal ini adalah instance Game yang sedang dibuat.

Pada baris this.loadingStuff = this.loadingStuff.bind(this);, kita mengikat metode loadingStuff() ke instance Game yang sedang dibuat. Dengan melakukan ini, kita memastikan bahwa ketika metode loadingStuff() dipanggil, nilai this dalam metode tersebut akan merujuk pada instance Game yang bersangkutan.

Ketika runner() dipanggil, instance Game dengan nama "Catur" dibuat, dan metode play() dari objek gamePlayer dipanggil. Karena kita menggunakan bind() dalam konstruktor Game, ketika play() dipanggil, nilai this dalam metode loadingStuff() tetap merujuk pada instance Game yang bersangkutan. Sehingga, saat metode loadingStuff() dieksekusi, outputnya akan mencetak "Permainan Catur akan segera dimulai!", mengacu pada nilai \_name dari instance Game yang sedang berjalan.

Dengan mengikat this menggunakan bind(), kita memastikan bahwa dalam konteks yang benar, yaitu saat metode loadingStuff() dipanggil, this merujuk pada instance yang diinginkan, dalam hal ini adalah instance Game.

Ketika kode tersebut Anda jalankan, kira-kira apa output pada console? Normalnya, mungkin Anda berpikir output yang dihasilkan adalah sebagai berikut:

Memuat komponen permainan ...

Permainan Catur akan segera dimulai!

Namun, ternyata salah! Sebenarnya nyatanya outputnya adalah seperti ini:

Memuat komponen permainan ...
Permainan undefined akan segera dimulai!

Jika Anda coba tuliskan console.log(this) di dalam fungsi loadingStuff dan jalankan ulang kodenya, Anda akan melihat konteks dari this di sana.

    { play: [Function: loadingStuff] }

Pantas saja, nilai this.name menjadi undefined karena this bukanlah instance dari Game. Alih-alih instance Game, ia malah menjadi objek gamePlayer. Mengapa bisa demikian? Hal ini tentu karena kita menetapkan fungsi loadingStuff pada properti play dari objek gamePlayer, sehingga this pada fungsi loadingStuff yang dipanggil dari objek gamePlayer akan dimasukkan dengan nilai objek gamePlayer.

Hal ini juga yang terjadi pada berkas routes.js dan handler.js di proyek kita. Alih-alih instance dari NotesHandler, this pada fungsi handler malah objek dari route.

Lalu, bagaimana solusinya? Cukup mudah!

Pada kode interaktif di atas, coba Anda tambahkan kode di bawah ini, tepatnya di constructor (setelah inisialisasi properti this.name).

    this.loadingStuff = this.loadingStuff.bind(this);

    Lihat dokumentasi yang diberikan MDN untuk mengetahui secara detail fungsi dari function.prototype.bind.

Kemudian jalankan kembali dan lihat output-nya. Sudah sesuai kan?

Ketahuilah! Fungsi bind adalah member dari Function.prototype di mana setiap function JavaScript dapat mengakses fungsi ini. Fungsi bind berfungsi untuk mengikat implementasi function agar ia tetap memiliki konteks sesuai nilai yang ditetapkan pada argumen yang diberikan pada fungsi bind tersebut.

Jadi dengan menuliskan kode di atas, itu berarti kita mengikat konteks this agar tetap bernilai instance dari Game (ini dilakukan karena keyword this digunakan di constructor di mana ia masih bernilai instance Game). Sejauh ini paham? Jika belum, Anda boleh bertanya pada diskusi ya.

Nah, ini pun berlaku untuk solusi bugs pada proyek kita. Silakan binding setiap fungsi handler yang ada pada NotesHandler di constructor hingga tampak seperti ini:

    class NotesHandler {
      constructor(service) {
        this._service = service;

        this.postNoteHandler = this.postNoteHandler.bind(this);
        this.getNotesHandler = this.getNotesHandler.bind(this);
        this.getNoteByIdHandler = this.getNoteByIdHandler.bind(this);
        this.putNoteByIdHandler = this.putNoteByIdHandler.bind(this);
        this.deleteNoteByIdHandler = this.deleteNoteByIdHandler.bind(this);
      }

      /** kode disembunyikan */
    }

    module.exports = NotesHandler;

Kemudian, simpan berkas handler.js dan coba uji kembali server menggunakan Postman.

202105121041014164be6de22580f67d19fc32354c0302.jpeg

YES! Kini seluruh pengujian berhasil lolos. Itu berarti restrukturisasi proyek yang kita lakukan berhasil.

Sekarang Anda bisa menghapus berkas-berkas lama yang sudah digunakan seperti src -> routes.js, src -> handler.js, dan src -> notes.js dengan rasa percaya diri.

Sehingga. sekarang proyek kita memiliki struktur seperti ini:

20210512104100c5ed7043712e35ea212b59a95f092119.jpeg

Penting! Bagi yang menggunakan version control Git di proyek ini, Anda bisa melakukan commit terhadap perubahan yang terjadi. Caranya, tuliskan perintah berikut di Terminal proyek:

    git add .

Kemudian, commit perubahannya dengan pesan “restructure with hapi plugin”.

    git commit -m "restructure with hapi plugin"

Terakhir, Anda bisa push perubahannya ke remote repository menggunakan perintah berikut:

    git push origin master


    Catatan:
    Source code dari latihan ini bisa Anda lihat pada repository: hapi-plugin.

==========================================================================================================================

Data Validation

Tahukah Anda bahwa salah satu tanggung jawab aplikasi Back-End adalah mengelola data. Data yang dikelola pun bisa bersumber dari mana saja, salah satunya dari client atau pengguna. Pengguna bisa mengirim apa pun ke sistem Anda selama aplikasi memberikan akses tersebut.

Namun, jika tidak ingin resource Anda dipenuhi oleh data “sampah” atau tak berkualitas, tindakan apa yang bisa Anda ambil sebagai back-end developer?

Jawabannya adalah validasi data. Validasi data menjadi salah satu hal yang krusial dalam pengembangan Back-End. Selain untuk memastikan pengguna mengirimkan data yang sesuai, validasi data juga bisa meminimalkan kemungkinan kejahatan yang dilakukan oleh pengguna seperti SQL Injection. Dengan adanya validasi data, kita bisa memastikan data yang dikirim tidak mengandung unsur yang berbahaya atau dapat mengganggu sistem.

“Never trust your user” adalah kata yang perlu kita ingat ketika mengembangkan aplikasi Back-End. Jangan pernah percaya informasi apa pun yang pengguna berikan, bahkan aplikasi Front-End Anda sekalipun yang telah menerapkan proses validasi. Hal ini karena kita tidak tahu bagaimana pengguna nakal dapat memanipulasi aplikasi front-end untuk mengirimkan data yang buruk.

Mari kita ambil contoh pada sistem yang dapat melakukan transfer saldo tabungan di bank.

202105240800387c9d056c8dce53b64f834f485ef0efd7.png

Perhatikan data yang terdapat pada gambar di atas. Pengguna hanya memiliki saldo sebesar IDR. 1.000.000, tetapi ia mencoba untuk mentransfer sebesar IDR 1.500.000. Meskipun terdapat validasi di sisi aplikasi front-end menggunakan JavaScript, namun tahukah Anda bahwa user bisa saja menghilangkan validasi tersebut dengan mematikan JavaScript di browser.

20210512110759dae491b22c80daf1ca4e79f3481ed227.jpeg

Dalam kasus ini, logika validation tidak akan jalan dan akhirnya data berhasil dikirimkan ke back-end. Bila back-end sepenuhnya mengandalkan validasi di front-end, malapetaka pun terjadi.

Mari kita lihat contoh lain yang lebih berhubungan dengan kita saat ini. Pada Notes API yang kita buat, kira-kira apa jadinya bila pengguna mengirimkan data title dengan nilai boolean, body dengan nilai number, dan tags dengan nilai string?

20210512110800be1cc01b7614aa18624c2bc2a49d232d.jpeg

Karena tidak adanya proses validasi, Notes API akan menerima dan menyimpan data secara mentah-mentah. Tentu ini akan mengganggu keberlangsungan sistem Anda ke depannya.

Lalu pertanyaanya, bagaimana cara melakukan validasi data? Tentu caranya bermacam-macam, tergantung kasus yang ingin Anda hadapi. Ada yang perlu memeriksa hingga level database, bahkan ada pula yang dapat ditangani dengan beberapa baris kode saja.

Untuk kasus transfer saldo, Anda bisa melakukan pengecekan jumlah saldo di database sebelum melakukan proses transfer. Anda harus melakukan query pada jumlah saldo yang aktif, kemudian bandingkan dengan jumlah saldo yang akan dikirim. Jika sesuai, barulah proses transfer bisa dilakukan.

Nah, untuk kasus yang kita hadapi di Notes API, sebenarnya proses validasi cukup dilakukan dengan memeriksa tipe dan nilai dari data yang dikirimkan client. Pastikan data yang dikirim itu masuk ke dalam spesifikasi yang sesuai. Untuk melakukannya, Anda bisa menggunakan if dan operator conditional.

Namun, masalah baru tiba ketika Anda menggunakan if dan operator conditional untuk memvalidasi data yang banyak dan kompleks. Yaitu, mau sebanyak dan serumit apa kode yang Anda tuliskan hanya untuk sekadar memvalidasi data?

Tak perlu khawatir, di JavaScript, kita bisa melakukan validasi data tersebut dengan bantuan paket Joi.

==========================================================================================================================

Data Validation Menggunakan Joi

20210512111407089dca6dbbef7481401418b4756c607d.jpegJoi merupakan tools yang populer dan andal untuk melakukan validasi data di JavaScript [2]. Joi dibuat oleh Sideway yang merupakan pengembang dari Hapi framework. Meskipun pengembangnya sama, Joi bukanlah bagian dari lingkungan framework Hapi. Ia menjadi tools terpisah dan dapat digunakan tanpa terikat pada satu framework saja.

Dalam memvalidasi data, Joi menggunakan pola schema description. Sehingga untuk memvalidasi data menggunakan Joi, kita perlu mendeskripsikan terlebih dahulu skema data yang diinginkan.

Untuk membuat schema pada Joi, gunakan method Joi.object(). Di dalamnya (pada parameter method), kita bisa mulai menuliskan schema dari objek yang ingin divalidasi.

    // membuat objek schema
    const schema = Joi.object({
     username: Joi.string().alphanum().min(3).max(30).required(),
     password: Joi.string().min(6).required(),
     repeatPassword: Joi.string().required().valid(Joi.ref("password")),
     email: Joi.string().email().required(),
    });

    Anda bisa mempraktikkan kode melalui platform replit.com di halaman berikut.

Value dari tiap properti objek schema diisi dengan method-method dari Joi. Method ini mendeskripsikan spesifikasi nilai yang harus dipenuhi untuk lolos proses validasi.

Berikut beberapa method Joi yang biasa digunakan:

    string() : Digunakan untuk menetapkan string sebagai tipe data pada properti.
    number() : Digunakan untuk menetapkan number sebagai tipe data.
    required() : Digunakan untuk menandakan bahwa properti objek wajib ditetapkan. Biasanya, method ini digunakan secara berantai, contohnya Joi.string().required() yang artinya properti wajib ditetapkan dan bertipe data string.
    array() : Digunakan untuk menetapkan properti haruslah sebuah array. Kita juga bisa lebih detail seperti menspesifikasikan hingga ke itemnya. Bila Anda ingin properti sebagai array dari string, maka tuliskan Joi.array().items(Joi.string()).
    email() : Merupakan method yang dapat memvalidasi bahwa nilai string adalah sebuah email. Umumnya, penggunaan method ini tampak seperti Joi.string().email().

Method pada Joi sangatlah beragam. Jangan pusing untuk mempelajari semuanya sekarang. Pelajarilah method-method lain ketika Anda sudah membutuhkannya. Anda bisa mencari referensi lengkapnya dari dokumentasi yang disediakan Joi.

Lalu, bagaimana cara melakukan validasinya? Mudah saja! Anda bisa gunakan fungsi validate() dari objek schema yang sudah dibuat, lalu berikan nilai atau objek yang hendak Anda validasi sesuai dengan schema yang telah ditetapkan.

    // membuat objek schema
    const schema = Joi.object({
     username: Joi.string().alphanum().min(3).max(30).required(),
     password: Joi.string().min(6).required(),
     repeatPassword: Joi.string().required().valid(Joi.ref("password")),
     email: Joi.string().email().required(),
    });
    // memvalidasi objek berdasarkan schema
    const validationResult = schema.validate({
     username: 'harryp',
     password: 'supersecretpassword',
     repeatPassword: 'supersecretpassword',
     email: 'harry@potter.com'
    });

Fungsi validate mengembalikan objek yang merupakan hasil dari validasi tersebut (validationResult). Dari validationResult, kita bisa mengetahui apakah objek yang diperiksa itu valid atau tidak.

    // membuat objek schema
    const schema = Joi.object({
     username: Joi.string().alphanum().min(3).max(30).required(),
     password: Joi.string().min(6).required(),
     repeatPassword: Joi.string().required().valid(Joi.ref("password")),
     email: Joi.string().email().required(),
    });

    // memvalidasi objek berdasarkan schema
    const validationResult = schema.validate({
     username: 'harryp',
     password: 'supersecretpassword',
     repeatPassword: 'supersecretpassword',
     email: 'harry@potter.com'
    });

    // menelaah hasil dari proses validasi
    if(validationResult.error) {
     console.log(`Validation error: ${validationResult.error.message}`);
    } else {
     console.log('Validasi berhasil')
    }

Bila validationResult.error tidak benilai undefined, itu berarti validasi gagal. Bahkan kita bisa melihat alasan mengapa validasi itu gagal melalui properti validationResult.error.message.

==========================================================================================================================

Menerapkan Data Validation pada Notes API

Kita sudah mengetahui cara melakukan validasi data menggunakan Joi. Mulai dari membuat objek schema, melakukan proses validasi berdasarkan schema, hingga mengevaluasi hasil validasinya.

Ketahuilah bahwa Notes API yang kita buat belum menerapkan data validation. Sehingga Notes API sangat rawan menerima data yang tidak sesuai dan dapat mengganggu fungsionalitas dari sistem ke depannya.

Nah, agar hal tersebut tidak terjadi lagi, pada latihan kali ini kita akan mencoba menerapkan proses validasi data dengan bantuan Joi.

==========================================================================================================================

Menerapkan Data Validation pada Notes API - Menyiapkan Skenario Pengujian

Di latihan kali ini, kita akan mencoba menerapkan pendekatan yang sedikit berbeda, yakni menggunakan pengujian Postman sebagai patokan keberhasilan dalam menerapkan proses validasi data.

Untuk itu, sebelum menuliskan kode aplikasi, tentu kita perlu menyiapkan terlebih dahulu kebutuhan pengujian di Postman. Kira-kira apa saja ya yang perlu kita uji untuk menerapkan validasi data?

Oke, mari kita telaah dulu keadaan dari aplikasi Notes API sekarang. Saat ini terdapat dua jalur di mana pengguna dapat mengirimkan data (objek note), yakni melalui POST /notes dan PUT /notes. Sehingga, kita perlu memastikan data yang dikirimkan pada kedua jalur tersebut merupakan objek note yang valid.

Untuk mengetahui valid dan tidaknya objek note yang dikirimkan pengguna, kita perlu tahu dulu spesifikasi dari objek notes tersebut. Oke, berikut adalah ketentuan dari objek note yang dapat diterima oleh Notes API:

    Wajib memiliki properti title dengan tipe string dan tidak boleh kosong.
    Wajib memiliki properti body dengan tipe string dan tidak boleh kosong.
    Wajib memiliki properti tags yang merupakan array dari string.

Cukup jelas? Lanjut!

Sekarang, mari kita coba buat skenario pengujian baru untuk route POST /notes dan PUT /notes. Berikut ketentuan skenarionya:

    Skenario 1 : Adding Notes with Bad Note Payload (Memasukkan catatan baru dengan data yang buruk).
    Skenario 2 : Update Note with Bad Note Payload (Mengubah catatan dengan data yang buruk).

Untuk masing-masing skenario perlu menjalankan spesifikasi testing berikut:

    Pastikan response memiliki status code 400 (bad request).
    Pastikan header response Content-Type memiliki nilai application/json; charset=utf-8.
    Pastikan body response adalah object.
    Pastikan body response memiliki properti dan nilai yang sesuai.

Yuk kita langsung buka saja aplikasi Postman dan buat 2 (dua) request baru sesuai skenario di dalam Notes API Test collection.

20210512113106b3ca3ad837a0d18e240aabd3170d59c3.jpeg

Untuk Adding Notes with Bad Note Payload, isikan request URL dengan method POST dan http://localhost:5000/notes.

20210512113105c59270086b341bc37e6cce9703b95aaf.jpeg

Untuk Update Note with Bad Note Payload, isikan request URL dengan method PUT dan http://localhost:5000/notes/{{noteId}}.

2021051211310688fc35f286edc06c93a38c7e69a478f3.jpeg

Sebelum menuliskan berkas testing, ada hal yang perlu Anda ketahui terlebih dahulu. Untuk body payload pada masing-masing skenario uji, kita akan gunakan data secara dinamis. Itu artinya, kita tidak akan menulis data JSON secara manual di body request, melainkan kita akan memanfaatkan semacam “dataset” yang disimpan pada variable environments.

Dengan pendekatan ini, kita bisa membuat pengujian pada satu Postman request yang dipanggil berulang kali dengan data body yang berbeda-beda. Tujuannya adalah untuk mencakup seluruh kemungkinan error yang dapat dilakukan oleh pengguna.

Mungkin terdengar membingungkan ya? Tak apa, jika masih bingung sementara ikuti saja instruksinya ya.

Silakan buka tabs Environments dan buat dua variabel environments baru bernama badNotePayloads dan currentBadNotePayload. Biarkan initial value dan current value-nya tetap kosong.

202105121131064a9f81bc0423b1d5e762ce222c1662f8.jpeg

Simpan perubahan pada Environment dengan menekan Save.

Kembali ke request Adding Notes with Bad Note Payload. Silakan buka tab Pre-request Script.

20210512113106549b88a38da8da0ffb68df2fc99d6a2a.jpeg

Di bagian ini, silakan tuliskan kode JavaScript pre-request berikut:

    let badNotePayloads = pm.environment.get('badNotePayloads');  // ini akan bertipe Array

    if (!badNotePayloads || badNotePayloads.length === 0) {
        // inisialisasi dengan sejumlah note yang tidak sesuai
        badNotePayloads = [
            { tags: ["Android", "Web"], body: "Isi dari catatan A" },
            { title: 1, tags: ["Android", "Web"], body: "Isi dari catatan A" },
            { title: "Catatan A", body: "Isi dari catatan A" },
            { title: "Catatan A", tags: [1, "2"], body: "Isi dari catatan A" },
            { title: "Catatan A", tags: ["Android", "Web"] },
            { title: "Catatan A", tags: ["Android", "Web"], body: true }
        ]
    }

    const currentBadNotePayload = badNotePayloads.shift();  // hapus index 0, geser sisanya
    pm.environment.set('currentBadNotePayload', JSON.stringify(currentBadNotePayload));
    pm.environment.set('badNotePayloads', badNotePayloads);

Ketahuilah bahwa kode JavaScript pada pre-request akan tereksekusi setiap kali request akan dijalankan. Nah, pre-request ini kita manfaatkan untuk menginisialisasi objek note yang hendak digunakan pada request.

Pada kode di atas, Anda juga bisa melihat kumpulan objek-objek (dataset) dari note yang dianggap tidak benar atau menimbulkan error. Ketika request dijalankan berulang-ulang, ia akan membawa objek note dari dataset secara satu per satu (bergeser karena pemanggilan fungsi shift) melalui variabel currentBadNotePayload.

Lanjut, silakan buka tabs Body dan gunakan raw -> JSON sebagai tipe data body. Kemudian, berikan nilai {{currentBadNotePayload}} pada data body-nya.

202105121131060d16c9581fb3492f81ececa8d7e1d0b9.jpeg

Dengan begitu, request ini akan membawa data yang ada di dalam variabel currentBadNotePayload setiap kali dijalankan.

Sampai di sini, semoga Anda sudah paham ya maksudnya.

Oke, sekarang kita bisa mulai menulis kode testing pada Adding Notes with Bad Payload. Silakan buka tab Tests, kemudian tuliskan kode testing sesuai spesifikasi testing berikut:

    pm.test('response status code should have 400 value', () => {
        pm.response.to.have.status(400);
    });

    pm.test('response Content-Type header should have application/json; charset=utf-8 value', () => {
      pm.expect(pm.response.headers.get('Content-Type')).to.equals('application/json; charset=utf-8');
    });

    pm.test('response body should be an object', () => {
        const responseJson = pm.response.json();
        pm.expect(responseJson).to.be.an('object');
    });

    pm.test('response body object should have correct property and value', () => {
        const responseJson = pm.response.json();
        pm.expect(responseJson).to.haveOwnProperty('status');
        pm.expect(responseJson.status).to.equals('fail');
        pm.expect(responseJson).to.haveOwnProperty('message');
        pm.expect(responseJson.message).to.be.ok;
    })

Jangan dulu beranjak, di akhir kode testing, silakan tambahkan kode yang diberi tanda tebal berikut ini ya.

    pm.test('response status code should have 400 value', () => {
        pm.response.to.have.status(400);
    });

    pm.test('response Content-Type header should have application/json; charset=utf-8 value', () => {
      pm.expect(pm.response.headers.get('Content-Type')).to.equals('application/json; charset=utf-8');
    });

    pm.test('response body should be an object', () => {
        const responseJson = pm.response.json();
        pm.expect(responseJson).to.be.an('object');
    });

    pm.test('response body object should have correct property and value', () => {
        const responseJson = pm.response.json();
        pm.expect(responseJson).to.haveOwnProperty('status');
        pm.expect(responseJson.status).to.equals('fail');
        pm.expect(responseJson).to.haveOwnProperty('message');
        pm.expect(responseJson.message).to.be.ok;
    });

    const repeatRequestUntilDatasetEmpty = () => {
        const badNotePayloads = pm.environment.get('badNotePayloads');
        if(badNotePayloads && badNotePayloads.length > 0) {
            postman.setNextRequest('Adding Notes with Bad Note Payload');
        }
    }
    repeatRequestUntilDatasetEmpty();

Kode tersebut berfungsi untuk memanggil ulang request 'Adding Notes with Bad Note Payload’ hingga badNotePayloads kosong. Namun perlu diketahui bahwa postman.setNextRequest hanya bekerja bila Anda menjalankan request melalui Postman collection. Request tidak akan dijalankan berulang bila Anda menjalankannya secara manual menggunakan tombol Send.

Simpan seluruh perubahan pada request Adding Notes with Bad Note Payload dan mari kita melangkah ke request selanjutnya.

Buka request Update Note with Bad Note Payload, kemudian buka tab Pre-request Script, dan tuliskan kode yang sama seperti pada request Adding Notes with Bad Note Payload.

    let badNotePayloads = pm.environment.get('badNotePayloads');  // ini akan bertipe Array

    if (!badNotePayloads || badNotePayloads.length === 0) {
        // inisialisasi dengan sejumlah note yang tidak sesuai
        badNotePayloads = [
            { tags: ["Android", "Web"], body: "Isi dari catatan A" },
            { title: 1, tags: ["Android", "Web"], body: "Isi dari catatan A" },
            { title: "Catatan A", body: "Isi dari catatan A" },
            { title: "Catatan A", tags: [1, "2"], body: "Isi dari catatan A" },
            { title: "Catatan A", tags: ["Android", "Web"] },
            { title: "Catatan A", tags: ["Android", "Web"], body: true }
        ]
    }

    const currentBadNotePayload = badNotePayloads.shift();  // hapus index 0, geser sisanya
    pm.environment.set('currentBadNotePayload', JSON.stringify(currentBadNotePayload));
    pm.environment.set('badNotePayloads', badNotePayloads);

Lanjut, silakan buka tabs Body dan gunakan format data raw -> JSON, lalu isi nilai body dengan variabel {{currentBadNotePayload}}.

2021051211310613c35f90d02b81b4fe02326e0694778f.jpeg

Setelah itu, kita bisa mulai menulis kode testing-nya. Nah, karena spesifikasi testing-nya identik dengan request Adding Notes with Bad Note Payload, kali ini Anda bisa isikan kode yang sama pada kode testing request.

    pm.test('response status code should have 400 value', () => {
        pm.response.to.have.status(400);
    });

    pm.test('response Content-Type header should have application/json; charset=utf-8 value', () => {
      pm.expect(pm.response.headers.get('Content-Type')).to.equals('application/json; charset=utf-8');
    });

    pm.test('response body should be an object', () => {
        const responseJson = pm.response.json();
        pm.expect(responseJson).to.be.an('object');
    });

    pm.test('response body object should have correct property and value', () => {
        const responseJson = pm.response.json();
        pm.expect(responseJson).to.haveOwnProperty('status');
        pm.expect(responseJson.status).to.equals('fail');
        pm.expect(responseJson).to.haveOwnProperty('message');
        pm.expect(responseJson.message).to.be.ok;
    });

    const repeatRequestUntilDatasetEmpty = () => {
        const badNotePayloads = pm.environment.get('badNotePayloads');

        if(badNotePayloads && badNotePayloads.length > 0) {
            postman.setNextRequest('Adding Notes with Bad Note Payload');
        }
    }

    repeatRequestUntilDatasetEmpty();

Pastikan sudah mengubah nama request di dalam fungsi postman.setNextRequest menjadi ‘Update Note with Bad Note Payload’ seperti kode berikut ini.

    const repeatRequestUntilDatasetEmpty = () => {
        const badNotePayloads = pm.environment.get('badNotePayloads');

        if(badNotePayloads && badNotePayloads.length > 0) {
            postman.setNextRequest('Update Note with Bad Note Payload');
        }
    }

Simpan seluruh perubahan pada request Update Notes with Bad Note Payload ya.

Terakhir, kita atur urutan kedua request tersebut tepat setelah Adding Notes dan Update Note. Caranya, cukup tekan dan geser menggunakan kursor.

20210512113106deaa1d47b1bdab7f8c477a232bb8694d.jpeg

Selesai! Yuk kita coba jalankan seluruh request menggunakan tombol Run pada Notes API Test Collection dan lihat hasil pengujiannya.

    Catatan: Pastikan Notes API server sedang beroperasi ya.

202105121131209b9dfec9a358d694f5b1422becfd57f1.jpeg

Waduh! Ternyata banyak sekali pengujian yang gagal. Santai, ini normal kok. Kita akan membuat pengujian ini lolos dengan menerapkan proses validasi data.

==========================================================================================================================

Menerapkan Data Validation pada Notes API - Membuat Notes Schema dan Validator

Sekarang saatnya kita memperbaiki pengujian dengan menerapkan proses validasi data. Kita tinggalkan dulu Postman dan buka kembali VSCode.

Seperti yang sudah Anda ketahui, kita akan menggunakan bantuan Joi dalam proses validasi data. Jadi, langkah pertama yang perlu kita lakukan adalah memasang paket Joi pada proyek Notes API.

Buka Terminal proyek dan tuliskan kode:

    npm install joi

Setelah Joi terpasang, buat folder baru di dalam src dengan nama validator.

202105121153272723b94aab4440083b6caba51d13b7d1.jpeg

Di dalam folder validator ini kita akan menyimpan seluruh berkas yang berhubungan dengan validasi data menggunakan Joi, seperti membuat schema dan fungsi dalam memvalidasi data atau payload itu sendiri.

Agar lebih terorganisir lagi, kita buat folder baru dengan nama notes di dalam src -> validator.

20210512115327db93e9a1ba967ca3143ce240bc56c61e.jpeg

Kemudian di dalam folder src -> validator -> notes, buat dua berkas dengan nama index.js dan schema.js.

202105121153262ad93eb580dcfd8d4b50f6866dd5cfc5.jpeg

Berkas schema.js akan digunakan untuk fokus membuat dan menuliskan objek schema data notes. Sedangkan berkas index.js akan fokus dalam membuat fungsi sebagai validator yang menggunakan schema dari schema.js. Cukup paham?

Oke, mari kita mulai dari membuat schema. Pada berkas schema.js, Anda bisa membuat objek schema dengan nama NotePayloadSchema. Kemudian, tetapkan spesifikasi schema seperti yang sudah Anda ketahui pada materi menyiapkan skenario pengujian.

    const Joi = require('joi');

    const NotePayloadSchema = Joi.object({
      title: Joi.string().required(),
      body: Joi.string().required(),
      tags: Joi.array().items(Joi.string()).required(),
    });

Terakhir, silakan ekspor nilai NotePayloadSchema agar dapat digunakan pada berkas JavaScript lain.

    const Joi = require('joi');

    const NotePayloadSchema = Joi.object({
      title: Joi.string().required(),
      body: Joi.string().required(),
      tags: Joi.array().items(Joi.string()).required(),
    });

    module.exports = { NotePayloadSchema };

Kita gunakan destructuring object untuk mengantisipasi pembuatan lebih dari satu nilai Schema yang di ekspor pada berkas ini ke depannya.

Yuk lanjut kita buat fungsi validasinya di berkas index.js.

Silakan buka index.js dan buat objek dengan nama NotesValidator. Kemudian, buat properti validateNotePayload dan berikan nilainya dengan fungsi kosong yang memiliki satu parameter payload seperti ini:

    const NotesValidator = {
      validateNotePayload: (payload) => {

      },
    };

Fungsi validateNotePayload ini nantinya akan berguna untuk melakukan validasi dan mengevaluasi apakah validasi itu berhasil atau tidak.

Jadi, ayo tuliskan kode validasi Joi dalam memvalidasi payload di dalam fungsi ini. Manfaatkan schema dari NotePayloadSchema yang sudah kita buat sebelumnya.

    const { NotePayloadSchema } = require('./schema');

    const NotesValidator = {
      validateNotePayload: (payload) => {
        const validationResult = NotePayloadSchema.validate(payload);
      },
    };

Lanjut, kita evaluasi validationResult. Jika properti error tidak undefined, maka kita bangkitkan error dengan membawa pesan dari properti validationResult.error.message.

Terakhir, kita ekspor objek NotesValidator agar dapat kita gunakan nanti pada berkas JavaScript lain.

    const { NotePayloadSchema } = require('./schema');

    const NotesValidator = {
      validateNotePayload: (payload) => {
        const validationResult = NotePayloadSchema.validate(payload);
        if (validationResult.error) {
          throw new Error(validationResult.error.message);
        }
      },
    };

    module.exports = NotesValidator;

Pembuatan schema dan validator sudah selesai. Simpan seluruh perubahan baik pada berkas index.js ataupun schema.js. Selanjutnya, kita akan coba gunakan validator ini pada plugin notes.

==========================================================================================================================

**Menerapkan Data Validation pada Notes API - Menggunakan NoteValidator pada Plugin Note**

Setelah pembuatan objek NoteValidator selesai, saatnya kita gunakan validator pada plugin notes.

Sama seperti NotesService, untuk mengirimkan data pada plugin, kita akan manfaatkan objek options. Oleh karena itu, yuk kita tambahkan nilai options plugin notes untuk validator di server.js.

Buka berkas src -> server.js, kemudian impor NotesValidator dari berkas src -> validator -> notes -> index.js.

    const Hapi = require('@hapi/hapi');
    const notes = require('./api/notes');
    const NotesService = require('./services/inMemory/NotesService');
    const NotesValidator = require('./validator/notes');

    /** kode disembunyikan */

Selanjutnya pada proses registrasi plugin notes--lebih tepatnya pada objek options--kita tambahkan properti validator dan beri nilai NotesValidator.

    /** kode disembunyikan */

    const init = async () => {
      const notesService = new NotesService();
      const server = Hapi.server({
        port: 5000,
        host: process.env.NODE_ENV !== 'production' ? 'localhost' : '0.0.0.0',
        routes: {
          cors: {
            origin: ['*'],
          },
        },
      });

      await server.register({
        plugin: notes,
        options: {
          service: notesService,
          validator: NotesValidator,
        },
      });

      await server.start();
      console.log(`Server berjalan pada ${server.info.uri}`);
    };

    init();

Simpan perubahan pada berkas server.js. Sekarang, mari kita beralih ke plugin notes.

Buka berkas src -> api -> notes -> index.js, lalu tambahkan properti validator pada parameter options di fungsi register dan gunakan validator sebagai argumen dalam membuat instances NoteHandler bersama dengan service.

    const NotesHandler = require('./handler');
    const routes = require('./routes');

    module.exports = {
      name: 'notes',
      version: '1.0.0',
      register: async (server, { service, validator }) => {
        const notesHandler = new NotesHandler(service, validator);
        server.route(routes(notesHandler));
      },
    };

Sekarang, buka berkas handler di src -> api -> notes -> handler.js dan tambahkan validator di parameter constructor serta inisialisasi nilainya sebagai properti this.\_validator.

    class NotesHandler {
      constructor(service, validator) {
        this._service = service;
        this._validator = validator;

        this.postNoteHandler = this.postNoteHandler.bind(this);
        this.getNotesHandler = this.getNotesHandler.bind(this);
        this.getNoteByIdHandler = this.getNoteByIdHandler.bind(this);
        this.putNoteByIdHandler = this.putNoteByIdHandler.bind(this);
        this.deleteNoteByIdHandler = this.deleteNoteByIdHandler.bind(this);
      }

      /** kode disembunyikan */
    }
    module.exports = NotesHandler;

Dengan demikian, sekarang kita bisa mengakses fungsi validateNotePayload melalui this.\_validator.

Kalau begitu, yuk langsung saja kita gunakan validateNotePayload di dalam postNoteHandler dan putNoteByIdHandler. Mengapa? Ini karena pada kedua fungsi tersebut kita mendapatkan data dari pengguna dalam bentuk payload.

Oke, silakan panggil this.\_validator.validateNotePayload dan berikan parameter dengan nilai request.payload untuk memvalidasi payload yang diberikan pengguna.

    class NotesHandler {
      /** kode disembunyikan */

      postNoteHandler(request, h) {
        try {
          this._validator.validateNotePayload(request.payload);
          const { title = 'untitled', body, tags } = request.payload;

          const noteId = this._service.addNote({ title, body, tags });

          const response = h.response({
            status: 'success',
            message: 'Catatan berhasil ditambahkan',
            data: {
              noteId,
            },
          });
          response.code(201);
          return response;
        } catch (error) {
          const response = h.response({
            status: 'fail',
            message: error.message,
          });
          response.code(400);
          return response;
        }
      }

     /** kode disembunyikan */

      putNoteByIdHandler(request, h) {
        try {
          this._validator.validateNotePayload(request.payload);
          const { id } = request.params;

          this._service.editNoteById(id, request.payload);

          return {
            status: 'success',
            message: 'Catatan berhasil diperbarui',
          };
        } catch (error) {
          const response = h.response({
            status: 'fail',
            message: error.message,
          });
          response.code(404);
          return response;
        }
      }

      /** kode disembunyikan */
    }

    module.exports = NotesHandler;

Lihat kode yang ditebalkan ya. Pastikan Anda memanggilnya sebelum mengonsumsi nilai dari request.payload itu sendiri. Bila salah peletakan, bisa-bisa data yang buruk tetap diproses. Apalagi bila Anda memanggil setelah aksi menyimpan atau mengubah note.

Setelah memanggil fungsi validasi di postNoteHandler dan putNoteByIdHandler, seharusnya proses validasi data berhasil diterapkan.

Silakan simpan perubahan pada berkas handler.js dan coba uji ulang API menggunakan Postman.

202105121328316a10730f6d92a0c22672776b381638fe.jpeg

Ah, ternyata masih ada pengujian yang gagal. Bila Anda lihat, pengujian yang gagal hanya di request “Update Note with Bad Note Payload”. Mengapa bisa demikian? Coba kita lihat pesan gagalnya.

response status code should have 400 value | AssertionError: expected response to have status code 400 but got 404

Ternyata error disebabkan oleh status code yang bukan bernilai 400, malah 404. Tentu ini tidak sama dengan ekspektasi kita. Seharusnya, bila terjadi validation error response code-nya 400 bukan 404.

Oke, sekarang kita lihat apa yang menyebabkan response mengembalikan status code 404 pada fungsi putNoteByIdHandler.

    putNoteByIdHandler(request, h) {
      try {
        this._validator.validateNotePayload(request.payload);
        const { id } = request.params;

        this._service.editNoteById(id, request.payload);

        return {
          status: 'success',
          message: 'Catatan berhasil diperbarui',
        };
      } catch (error) {
        const response = h.response({
          status: 'fail',
          message: error.message,
        });
        response.code(404);
        return response;
      }
    }

Terjawab sudah! Ternyata ada bagian block catch. Kita menetapkan status code 404 karena kita berasumsi bahwa setiap eror yang terjadi pada proses memperbarui catatan adalah eror karena tidak ditemukannya resource.

Lantas bagaimana solusinya? Apakah kita ganti saja 404 dengan 400? Hmm, mungkin itu membuat pengujian lolos, tetapi bukan merupakan solusi yang tepat. Bagaimana dengan nasib ketika terjadi eror karena resource tidak ditemukan? Tentu status code 400 tidaklah relevan.

Tak usah bingung. Inilah saatnya kita gunakan teknik custom error agar dapat memberikan keterangan eror secara spesifik.

==========================================================================================================================

Menerapkan Custom Exceptions - Mengenal Jenis Kesalahan Yang Terjadi di Transaksi HTTP

Seperti yang sudah Anda ketahui, tidak semua request HTTP yang masuk ke server dapat ditangani dengan baik. Aplikasi server dianjurkan untuk menolak permintaan server bila terdapat sesuatu yang salah dengan permintaan client. Namun, aplikasi server tidak boleh secara mentah-mentah menolak permintaan tersebut tanpa memberikan alasan yang jelas mengapa permintaan client tidak dapat diproses.

202105240802006754aaf509acc36d2d1592b9f369f6f1.png

Tahukah Anda bahwa kesalahan dapat terjadi karena dua pihak, yang pertama disebabkan oleh pihak client dan yang kedua oleh pihak server.

Kesalahan oleh client dapat terjadi karena permintaan yang diajukan tidak ada, bukan haknya, tidak memenuhi spesifikasi, atau kesalahan-kesalahan lain yang timbul karena perbuatan client. Etika dalam merespons kesalahan yang disebabkan oleh client adalah dengan menetapkan status code 400 (bad request). Namun untuk kesalahan seperti not found, unauthorized, atau forbidden memiliki status code yang lebih spesifik.

    400 (Bad Request) : Permintaan client gagal dijalankan karena proses validasi input dari client gagal.
    401 (Unauthorized) : Permintaan client gagal dijalankan. Biasanya ini disebabkan karena pengguna belum melakukan proses autentikasi.
    403 (Forbidden) : Permintaan client gagal dijalankan karena ia tidak memiliki hak akses ke resource yang diminta.
    404 (Not Found) : Permintaan client gagal dijalankan karena resource yang diminta tidak ditemukan.

Lalu, bagaimana dengan kesalahan yang disebabkan oleh server? Nah, ini adalah kesalahan yang datangnya bukan dari client. Kesalahan ini bisa disebabkan oleh developer yang salah menuliskan program (sering terjadi di JavaScript), server atau database yang sedang down, dan kesalahan lainnya. Jika terjadi kesalahan server, maka respons yang dikembalikan harus memiliki variasi kode status bernilai 500 (Internal Server Error), seri status 500 lainnya (saat ini ada 500-511).

Ketika permintaan client gagal, terutama bila kesalahan tersebut terjadi karena client, kita harus mengembalikan status code yang sesuai dengan kesalahan yang terjadi. Penggunaan response code yang tepat dapat menghindari kebingungan client/user dalam memanfaatkan API.

==========================================================================================================================

Menerapkan Custom Exceptions - Membuat Custom Error

Pada materi sebelumnya, Anda sudah mengetahui macam-macam error yang terjadi pada HTTP transaction serta pentingnya memberikan response error yang sesuai, kini kita akan coba menerapkan praktik yang baik dalam menangani sebuah eror pada Notes API.

Saat ini, ketika kita membangkitkan eror, entah itu disebabkan oleh tidak ditemukannya resource atau proses validasi data gagal, kita selalu menggunakan class Error secara generic. Hal ini menyulitkan kita untuk membedakan apa yang menyebabkan eror tersebut dibangkitkan.

Agar dapat mudah mengidentifikasi eror secara lebih spesifik, maka kita perlu menerapkan teknik custom error. Berdasarkan kebutuhan Notes API saat ini, kita perlu membuat 3 (tiga) custom error, yakni:

    ClientError (extends dari Error) : Custom error yang mengindikasikan eror karena masalah yang terjadi pada client. ClientError ini bersifat abstrak karena client error bisa lebih spesifik. Sehingga, sebaiknya Anda tidak membangkitkan error dengan menggunakan class ini secara langsung, tetapi gunakanlah turunannya.
    NotFoundError (extends dari ClientError) : Custom error yang mengindikasikan eror karena resource yang diminta client tidak ditemukan.
    InvariantError (extends dari ClientError) : Custom error yang mengindikasikan eror karena kesalahan bisnis logic pada data yang dikirimkan oleh client. Kesalahan validasi data merupakan salah satu InvariantError.

Yuk sekarang kita langsung saja buat ketiga custom error di atas.

Buat folder baru bernama exceptions di dalam src. Kemudian di dalam berkas tersebut, buat tiga berkas JavaScript dengan nama ClientError.js, NotFoundError.js, dan InvariantError.js.

202105121431055bcc0d54d23047857a6bb399c0097884.jpeg

Kita mulai dari ClientError.js. Silakan buat class ClientError yang mewarisi Error dan buat constructor yang menerima dua parameter message dan code. Untuk parameter code, beri nilai default 400.

    class ClientError extends Error {
      constructor(message, statusCode = 400) {

      }
    }

Di dalam constructor, panggil fungsi super dengan membawa nilai message; inisialisasi nilai code pada this.statusCode; tetapkan this.name dengan nilai “ClientError”; dan ekspor ClientError agar dapat digunakan oleh berkas lain.

    class ClientError extends Error {
      constructor(message, statusCode = 400) {
        super(message);
        this.statusCode = statusCode;
        this.name = 'ClientError';
      }
    }

    module.exports = ClientError;

Lanjut ke berkas InvariantError.js. Buat class dengan nama InvariantError yang mewarisi class ClientError dan buat constructor yang menerima satu parameter bernama message.

    const ClientError = require('./ClientError');

    class InvariantError extends ClientError {
      constructor(message) {

      }
    }

Di dalam constructor, panggil fungsi super dengan membawa nilai message dan tetapkan this.name dengan nilai “InvariantError”.

    const ClientError = require('./ClientError');

    class InvariantError extends ClientError {
      constructor(message) {
        super(message);
        this.name = 'InvariantError';
      }
    }

Karena InvariantError memiliki status code 400, maka kita tidak perlu menetapkan status code di sini. Sebab secara default, turunan ClientError akan memiliki nilai status code 400.

Jangan lupa ekspor class InvariantError agar bisa digunakan pada berkas lain.

    const ClientError = require('./ClientError');

    class InvariantError extends ClientError {
      constructor(message) {
        super(message);
        this.name = 'InvariantError';
      }
    }

    module.exports = InvariantError;

Yuk kita lanjut ke custom error terakhir.

Silakan buka berkas NotFoundError.js dan buat class NotFoundError yang mewarisi ClientError dan buat constructor yang menerima parameter bernama message.

    const ClientError = require('./ClientError');

    class NotFoundError extends ClientError {
      constructor(message) {

      }
    }

Di dalamnya, panggil fungsi super dengan membawa nilai message dan 404 sebagai statusCode; tetapkan this.name dengan nilai “NotFoundError”; dan jangan lupa ekspor class NotFoundError.

    const ClientError = require('./ClientError');

    class NotFoundError extends ClientError {
      constructor(message) {
        super(message, 404);
        this.name = 'NotFoundError';
      }
    }

    module.exports = NotFoundError;

Simpan seluruh perubahan, baik pada ClientError.js, InvariantError.js, ataupun NotFoundError.js.

Oke, sekarang kita bisa ubah kode untuk membangkitkan eror dengan menggunakan custom error ini.

Kita ubah dulu penerapan eror pada berkas src -> services -> inMemory -> NotesService.js. Pertama-tama pada fungsi addNote, temukan baris kode berikut:

    throw new Error('Catatan gagal ditambahkan');

Lalu ubah menjadi seperti ini:

    throw new InvariantError('Catatan gagal ditambahkan');

Lanjut, pada fungsi getNoteById, temukan baris kode berikut:

    throw new Error('Catatan tidak ditemukan');

Ubahlah menjadi seperti ini:

    throw new NotFoundError('Catatan tidak ditemukan');

Kemudian pada fungsi editNoteById, temukan baris kode berikut:

    throw new Error('Gagal memperbarui catatan. Id tidak ditemukan');

Lalu ubah menjadi seperti ini:

    throw new NotFoundError('Gagal memperbarui catatan. Id tidak ditemukan');

Terakhir pada fungsi deleteNoteById, temukan baris kode berikut:

    throw new Error('Catatan gagal dihapus. Id tidak ditemukan');

Ubahlah menjadi seperti ini:

    throw new NotFoundError('Catatan gagal dihapus. Id tidak ditemukan');

Jangan lupa untuk impor InvariantError dan NotFoundError pada NotesServices.js.

    const { nanoid } = require('nanoid');
    const InvariantError = require('../../exceptions/InvariantError');
    const NotFoundError = require('../../exceptions/NotFoundError');

    /** kode disembunyikan */

Lanjut ya!

Buka berkas src -> validator -> notes -> index.js, di dalam fungsi validateNotePayload, temukan baris kode berikut:

    throw new Error(validationResult.error.message);

Lalu ubahlah menjadi seperti ini:

    throw new InvariantError(validationResult.error.message);

Jangan lupa impor InvariantError pada index.js ya.

    const InvariantError = require('../../exceptions/InvariantError');
    const { NotePayloadSchema } = require('./schema');

    /** kode disembunyikan */

Paling akhir! Setelah selesai mengimplementasikan custom error, Sekarang saatnya kita ubah cara dalam menangani error yang dibangkitkan pada NotesHandler. Silakan buka berkas src -> api -> notes -> handler.js, lalu ubah seluruh penanganan error menjadi kode yang diberi tanda tebal.

    const ClientError = require('../../exceptions/ClientError');

    class NotesHandler {
      constructor(service, validator) {
        this._service = service;
        this._validator = validator;

        this.postNoteHandler = this.postNoteHandler.bind(this);
        this.getNotesHandler = this.getNotesHandler.bind(this);
        this.getNoteByIdHandler = this.getNoteByIdHandler.bind(this);
        this.putNoteByIdHandler = this.putNoteByIdHandler.bind(this);
        this.deleteNoteByIdHandler = this.deleteNoteByIdHandler.bind(this);
      }

      postNoteHandler(request, h) {
        try {
          this._validator.validateNotePayload(request.payload);
          const { title = 'untitled', body, tags } = request.payload;

          const noteId = this._service.addNote({ title, body, tags });

          const response = h.response({
            status: 'success',
            message: 'Catatan berhasil ditambahkan',
            data: {
              noteId,
            },
          });
          response.code(201);
          return response;
        } catch (error) {
          if (error instanceof ClientError) {
            const response = h.response({
              status: 'fail',
              message: error.message,
            });
            response.code(error.statusCode);
            return response;
          }

          // Server ERROR!
          const response = h.response({
            status: 'error',
            message: 'Maaf, terjadi kegagalan pada server kami.',
          });
          response.code(500);
          console.error(error);
          return response;
        }
      }

      getNotesHandler() {
        const notes = this._service.getNotes();
        return {
          status: 'success',
          data: {
            notes,
          },
        };
      }

      getNoteByIdHandler(request, h) {
        try {
          const { id } = request.params;
          const note = this._service.getNoteById(id);
          return {
            status: 'success',
            data: {
              note,
            },
          };
        } catch (error) {
          if (error instanceof ClientError) {
            const response = h.response({
              status: 'fail',
              message: error.message,
            });
            response.code(error.statusCode);
            return response;
          }

          // Server ERROR!
          const response = h.response({
            status: 'error',
            message: 'Maaf, terjadi kegagalan pada server kami.',
          });
          response.code(500);
          console.error(error);
          return response;
        }
      }

      putNoteByIdHandler(request, h) {
        try {
          this._validator.validateNotePayload(request.payload);
          const { id } = request.params;

          this._service.editNoteById(id, request.payload);

          return {
            status: 'success',
            message: 'Catatan berhasil diperbarui',
          };
        } catch (error) {
          if (error instanceof ClientError) {
            const response = h.response({
              status: 'fail',
              message: error.message,
            });
            response.code(error.statusCode);
            return response;
          }

          // Server ERROR!
          const response = h.response({
            status: 'error',
            message: 'Maaf, terjadi kegagalan pada server kami.',
          });
          response.code(500);
          console.error(error);
          return response;
        }
      }

      deleteNoteByIdHandler(request, h) {
        try {
          const { id } = request.params;
          this._service.deleteNoteById(id);

          return {
            status: 'success',
            message: 'Catatan berhasil dihapus',
          };
        } catch (error) {
          if (error instanceof ClientError) {
            const response = h.response({
              status: 'fail',
              message: error.message,
            });
            response.code(error.statusCode);
            return response;
          }

          // Server ERROR!
          const response = h.response({
            status: 'error',
            message: 'Maaf, terjadi kegagalan pada server kami.',
          });
          response.code(500);
          console.error(error);
          return response;
        }
      }
    }

    module.exports = NotesHandler;

Simak kode yang ditebalkan ya. Pada error handling kali ini, lebih tepatnya pada block catch, terdapat proses evaluasi objek error yang dihasilkan.

Bila error merupakan turunan dari ClientError, maka kita bisa memberikan detail informasi terkait error apa yang terjadi kepada client melalui properti error.message dan error.statusCode.

Namun bila bukan ClientError--itu berarti server error--maka secara default kita bisa merespons dengan pesan, “Maaf, terjadi kegagalan pada server kami” dan 500 sebagai nilai status codenya. Mungkin Anda akan mengerutkan dahi dan berkata, “Loh, mengapa pesannya tidak ambil dari error.message saja? Kan itu lebih menjelaskan errornya kepada client?”

Benar sih pesannya akan lebih detail, tetapi pesan tersebut tidak akan berguna untuk client dan malah menimbulkan bahaya bila dalam pesan error tersebut mengandung informasi yang sensitif. Pesan yang dihasilkan server error bukan ditujukan untuk client, melainkan untuk kita sebagai developer. Tujuannya, agar kita dapat mengetahui penyebab terjadinya server error dan penanganannya menjadi lebih cepat.

Maka dari itu, pada server error, kita bisa log error tersebut menggunakan console.error() sebelum mengembalikan response agar error yang terjadi bisa kita lihat pada Terminal proyek.

Mari kita lanjutkan. Dengan mengubah cara penanganan error pada fungsi handler, seharusnya Notes API saat ini sudah mampu mengembalikan response error sesuai dengan kasus yang terjadi.

Silakan simpan perubahan pada berkas handler.js dan coba uji kembali Notes API menggunakan Postman.

202105121431065dd43e7175281925800e9bff7bfe7643.jpeg

Mantap! Sekarang sudah tidak ada lagi pengujian yang gagal. Selamat ya!

Penting!

Bagi Anda yang menggunakan version control Git di proyek ini. Jangan lupa untuk melakukan commit terhadap perubahan yang terjadi. Caranya, tuliskan perintah berikut di Terminal proyek.

    git add .

Kemudian commit perubahannya dengan pesan “data validation implemented”.

    git commit -m "data validation implemented"

Terakhir, Anda bisa push perubahannya ke remote repository menggunakan perintah:

    git push origin master


    Catatan:
    Source code dari latihan ini bisa Anda lihat pada repository: data-validation.

==========================================================================================================================

eploy Perubahan Hapi Plugin dan Data Validation

Selamat ya! Sejauh ini Anda sudah berhasil melakukan restrukturisasi proyek dengan memanfaatkan Hapi plugin. Anda juga telah berhasil menerapkan proses data validation menggunakan Joi. Dengan begitu, kini proyek Notes API memiliki struktur yang mudah untuk dikembangkan dan aman untuk menerima data dari pengguna. Tak hanya itu, sekarang Notes API Anda sudah lebih siap untuk digunakan secara publik, yeay!

Eh tapi jangan lupa ya, perubahan yang kita lakukan masih di lokal alias tahap development. Kita belum menerapkan perubahan di server production yang ada di Amazon Elastic Compute Cloud (Amazon EC2). Yuk, tanpa berlama-lama lagi kita perbarui saja server yang ada di EC2.

Sebelum itu, pastikan Anda sudah commit seluruh perubahan yang ada di local repository dan push ke remote repository ya. Jika sudah, Anda bisa langsung mengakses EC2 instance.

Silakan buka Terminal/PowerShell/CMD pada directory di mana Anda menyimpan key pairs (key.pem) untuk akses EC2 instance. Kemudian tuliskan kode berikut:

    ssh -i "<key>.pem" <alamat instance EC2>

    Ganti <key> dengan nama berkas .pem yang Anda punya, lalu ubah <alamat instance EC2> dengan public DNS dari EC2 instance Anda. Bila Anda belum mengetahui cara mengakses EC2, disarankan untuk lihat tutorial yang diberikan oleh AWS tentang Connect to your Linux instance using SSH.

Setelah berhasil masuk ke EC2 instance, masuklah ke folder notes-app-back-end dengan perintah:

    cd notes-app-back-end

20210512162907471788b1b02c0f3185d0e0abbcbe6e7d.jpeg

Kemudian, update proyek dari remote repository dengan menggunakan perintah:

    git pull origin master

202105121629087ab8139d9ac258b52da14abd683a0ca2.jpeg

Selepas itu, instal beberapa package yang digunakan pada perubahan saat ini. Silakan tuliskan perintah:

    npm install

20210512162909df6e68804e976e685e89a2455c7af0fc.jpeg

Kemudian, restart process manager untuk menjalankan ulang notes-api server. Gunakan perintah:

    pm2 restart notes-api

20210512162908f5cd45ea7be643ce07f8137bbf875234.jpeg

Untuk memastikan server berjalan dengan baik, silakan lihat pm2 logs dengan cara menuliskan perintah:

    pm2 logs

20210512162908a96bfdb0d928d52c8c7e8830ba51c473.jpeg

Pastikan logs yang ada di paling bawah tampak seperti itu ya. Jika sudah aman, itu menandakan bahwa proses deploy telah selesai. Yeah!

    Catatan: Untuk keluar dari logs, gunakan kombinasi tombol CTRL + C

Anda bisa coba akses Notes API dengan mengunjungi IP publik EC2 dan port 5000. Anda juga bisa mengujinya melalui Postman dan juga aplikasi Notes Apps.

Cara menghubungkan Notes API dengan Notes Apps:

    Silakan klik tombol Change URL.
    2021030810464429e07f2c36082e9f83396e087587da00.png

    Lalu, isi dengan host beserta port dari web server yang Anda buat. Contohnya “localhost:5000”
    20210308104657da3785c63dc2ddcd9de3ec6a541b11bd.png
    Setelah Anda melihat URL dari web server, maka web server dan aplikasi client sudah terhubung.2021030810470899d7824d86fee9ce6aca6a6adc3e8176.png

==========================================================================================================================

Ikhtisar Hapi Plugin dan Data Validation

Anda berada di akhir dari modul Hapi Plugin dan Data Validation. Mari kita uraikan apa saja kemampuan yang seharusnya sudah Anda miliki.

    Mengetahui Hapi Plugin, cara membuat Hapi Plugin, serta menggunakannya pada Hapi Server.
    Anda mampu restrukturisasi proyek Notes API dengan menggunakan teknik Plugin.
    Mengetahui data validation dan pentingnya menerapkan proses validasi data.
    Mengetahui Joi sebagai tools dalam memvalidasi data, mampu membuat Joi schema, dan memvalidasi data berdasarkan schema.
    Anda mampu menerapkan proses validasi data pada proyek Notes API dengan bantuan Joi.
    Anda mampu membuat custom error dalam membangkitkan dan menangani error yang spesifik.
    Anda mampu memasang (deploy) perubahan yang terjadi di lokal ke EC2 instance.

Dengan uraian tersebut, diharapkan Anda dapat memahami semua materi yang telah disampaikan. Jika belum, Anda bisa ulas kembali materi yang diberikan pada modul ini dan menanyakannya di forum diskusi. Untuk Anda yang sudah merasa mantap, yuk lanjut ke modul berikutnya!

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================

==========================================================================================================================
